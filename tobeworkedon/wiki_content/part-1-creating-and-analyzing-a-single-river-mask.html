<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Part 1 - Creating and Analyzing a Single River Mask</title>
<meta name="identifier" content="g20d9f7eddb4adcae712a757d636f5afe"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
</head>
<body>
<p><span>In this section, we will prepare an image and calculate some simple morphological attributes of a river. To do this, we will use a pre-classified image of surface water occurrence, identify which pixels represent the river and channel bars, and finally calculate the centerline, width, and bank characteristics.&nbsp;</span></p>
<p><span>You will need to start with a boilerplate script below. &nbsp;Copy and paste the code below into Google Earth Engine.</span></p>
<pre><br>var aoi =&nbsp;<br>&nbsp; &nbsp; /* color: #d63000 */<br>&nbsp; &nbsp; /* shown: false */<br>&nbsp; &nbsp; /* displayProperties: [<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; "type": "rectangle"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; ] */<br>&nbsp; &nbsp; ee.Geometry.Polygon(<br>&nbsp; &nbsp; &nbsp; &nbsp; [[[-67.18414102495456, -11.09095257894929],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-67.18414102495456, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.09095257894929]]], null, false);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>var sword = ee.FeatureCollection("projects/gee-book/assets/A2-4/SWORD");<br><br><br>var getUTMProj = function(lon, lat) {<br>&nbsp; &nbsp; // given longitude and latitude (in degree decimals) return EPSG string for the&nbsp;<br>&nbsp; &nbsp; // corresponding UTM projection<br>&nbsp; &nbsp; // see https://apollomapping.com/blog/gtm-finding-a-utm-zone-number-easily and<br>&nbsp; &nbsp; // https://sis.apache.org/faq.html<br>&nbsp; &nbsp; var utmCode = ee.Number(lon).add(180).divide(6).ceil().int();<br>&nbsp; &nbsp; var output = ee.Algorithms.If(ee.Number(lat).gte(0),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:326').cat(utmCode.format('%02d')),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:327').cat(utmCode.format('%02d')));<br>&nbsp; &nbsp; return (output);<br>};<br><br>var coords = aoi.centroid(30).coordinates();<br>var lon = coords.get(0);<br>var lat = coords.get(1);<br>var crs = getUTMProj(lon, lat);<br>var scale = ee.Number(30);<br><br>var rpj = function(image) {<br>&nbsp; &nbsp; return image.reproject({<br>&nbsp; &nbsp; &nbsp; &nbsp; crs: crs,<br>&nbsp; &nbsp; &nbsp; &nbsp; scale: scale<br>&nbsp; &nbsp; });<br>};<br><br><span>&nbsp;</span></pre>
<p><span>The script includes our example area of interest (in the variable </span><span>aoi</span><span>) and two helper functions for reprojecting data to the local UTM coordinates. We force this projection and scale for many of our map layers because we are trying to observe and measure the river morphology. As data is viewed at different zoom levels, the shapes and apparent connectivity of many water bodies will change. To allow a given dataset to be viewed with the same detail at multiple scales, we can force the data to be reprojected, as we do here.&nbsp;&nbsp;</span></p>
<p><span>The Joint Research Centre’s surface water occurrence dataset (Pekel et al. 2016) classified the entire Landsat 5, 7, and 8 histories and produced annual maps identifying seasonal and permanent water classes. Here, we will include both seasonal and permanent water classes (represented by pixel values of ≥2) as water pixels (with value = 1) and the rest as non-water pixels (with value = 0). In this section, we will look at only one image at a time by choosing the image from the year 2000. Copy and past the code below, </span><span>bg</span><span> is a dark background layer for other map layers to be easily seen.</span></p>
<pre><span>// IMPORT AND VISUALIZE SURFACE WATER MASK.<br>// Surface water occurrence dataset from the JRC (Pekel et al., 2016).<br><strong>var</strong> jrcYearly = ee.ImageCollection('JRC/GSW1_3/YearlyHistory');<br><br>// Select the seasonal and permanent pixels image representing the year 2000<br><strong>var</strong> watermask = jrcYearly.filter(ee.Filter.eq('year', 2000)).first()<br>&nbsp; &nbsp; .gte(2).unmask(0)<br>&nbsp; &nbsp; .clip(aoi);<br><br>Map.centerObject(aoi);<br>Map.addLayer(ee.Image.constant(0), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; palette: ['black']<br>}, 'bg', <strong>false</strong>);<br>Map.addLayer(watermask, {}, 'watermask', <strong>false</strong>);</span></pre>
<p><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-10-26%20at%2010.19.28%E2%80%AFAM.png" alt="screenshot of the result" loading="lazy"></p>
<p><span>Next, we clean up the water mask by filling in small gaps by performing a closing operation (dilation followed by erosion). Areas of non-water pixels inside surface water bodies in the water mask may represent small channel bars, which we will fill to create a simplified water mask. We identify these bars using vectorization; however, you could do a similar operation with the </span><span>connectedPixelCount</span><span> method for bars up to 256 pixels in size. Filling in these small bars in the river mask improves the creation of a new centerline later in the lab.&nbsp;</span></p>
<pre><span>// REMOVE NOISE AND SMALL ISLANDS TO SIMPLIFY THE TOPOLOGY.</span><span><br></span><span><br></span><span>// a. Image closure operation to fill small holes.</span><span><br></span><span>watermask = watermask.</span><span>focal_max</span><span>().</span><span>focal_min</span><span>();</span><span><br></span><span><br></span><span>// b. Identify small bars and fill them in to create a filled water mask.</span><span><br></span><strong>var</strong><span> MIN_SIZE = </span><span>2E3</span><span>;</span><span><br></span><strong>var</strong><span> barPolys = watermask.</span><span>not</span><span>().</span><span>selfMask</span><span>()</span><span><br></span><span>&nbsp; &nbsp; .</span><span>reduceToVectors</span><span>({</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; geometry: </span><span>aoi</span><span>,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; scale: </span><span>30</span><span>,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; eightConnected: </span><strong>true</strong><span><br></span><span>&nbsp; &nbsp; })</span><span><br></span><span>&nbsp; &nbsp; .</span><span>filter</span><span>(</span><span>ee</span><span>.</span><span>Filter.lte</span><span>(</span><span>'count'</span><span>, MIN_SIZE)); </span><span>// Get small polys.</span><span><br></span><strong>var</strong><span> filled = watermask.</span><span>paint</span><span>(barPolys, </span><span>1</span><span>);</span><span><br></span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(filled), {</span><span><br></span><span>&nbsp; &nbsp; min: </span><span>0</span><span>,</span><span><br></span><span>&nbsp; &nbsp; max: </span><span>1</span><span><br></span><span>}, </span><span>'filled water mask'</span><span>, </span><strong>false</strong><span>);</span><br><br><br></pre>
<p><span><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-10-26%20at%2010.20.56%E2%80%AFAM.png" alt="Screenshot 2023-10-26 at 10.20.56 AM.png" loading="lazy"></span></p>
<p><span>So that you know, we forced reprojection of the map layer using the helper function </span><span>rpj</span><span>. This means we must be careful to keep our domain small enough to be processed at the set scale when calculating on the fly in the Code Editor; otherwise, we will run out of memory. The reprojection may not be necessary when exporting the output using a task.</span></p>
<p><span><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-10-26%20at%2010.09.57%E2%80%AFAM.png" alt="concepts of the different masks" loading="lazy"></span></p>
<p><span>In the following step, we extract water bodies in the water mask corresponding to rivers. We will define a river mask (Figure D) to be pixels connected to the river centerline according to the filled water mask. The channel mask (Figure C) is also defined by connectivity but excludes the small bars, giving us more accurate widths and areas for change detection in later sections.</span></p>
<p><span>We can extract the river mask by checking the water pixels’ connectivity to a provided river location database. Specifically, we use the Earth Engine method</span><span> </span><span>cumulativeCost</span><span> </span><span>to identify connectivity between the filled water mask and the pixels corresponding to the river dataset. By inverting the filled mask, the cost to traverse water pixels is 0, and the cost over land pixels is 1. Pixels in the cost map with a value of 0 are entirely connected to the Surface Water and Ocean Topography (SWOT) Mission River Database (SWORD) centerline points by water, and pixels with values greater than 0 are separated from SWORD by land. The SWORD data, which were loaded as assets in the starter script, have some points located on land, either because the channel bifurcates or because the channel has migrated, so we must exclude those from our cumulative cost parameter </span><span>source</span><span>, or they will appear as single pixels of 0 in our cost map.&nbsp;</span></p>
<p><span>The </span><span>maxDistance</span><span> </span><span>parameter must be set to capture the maximum distance between centerline points and river pixels. In a single-threaded river with an accurate centerline, the ideal</span><span> </span><span>maxDistance</span><span> </span><span>value would be about half the river width. However, in reality, the centerlines are not perfect, and large islands may separate pixels from their nearest centerline. Unfortunately, increasing </span><span>maxDistance</span><span> </span><span>has a large computational penalty, so some tweaking is required to get an optimal value. We can set </span><span>geodeticDistance</span><span> </span><span>to</span><span> </span><strong>false</strong><span> </span><span>to regain some computational efficiency, because we are not worried about the accuracy of the distances.</span></p>
<pre><span>// IDENTIFYING RIVERS FROM OTHER TYPES OF WATER BODIES.</span><span><br></span><span>// Cumulative cost mapping to find pixels connected to a reference centerline.</span><span><br></span><strong>var</strong><span> costmap = filled.</span><span>not</span><span>().</span><span>cumulativeCost</span><span>({</span><span><br></span><span>&nbsp; &nbsp; source: watermask.</span><span>and</span><span>(</span><span>ee</span><span>.</span><span>Image</span><span>().</span><span>toByte</span><span>().</span><span>paint</span><span>(</span><span>sword</span><span>,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>1</span><span>)),</span><span><br></span><span>&nbsp; &nbsp; maxDistance: </span><span>3E3</span><span>,</span><span><br></span><span>&nbsp; &nbsp; geodeticDistance: </span><strong>false</strong><span><br></span><span>});</span><span><br></span><span><br></span><strong>var</strong><span> rivermask = costmap.</span><span>eq</span><span>(</span><span>0</span><span>).</span><span>rename</span><span>(</span><span>'riverMask'</span><span>);</span><span><br></span><strong>var</strong><span> channelmask = rivermask.</span><span>and</span><span>(watermask);</span><span><br></span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(</span><span>sword</span><span>, {</span><span><br></span><span>&nbsp; &nbsp; color: </span><span>'red'</span><span><br></span><span>}, </span><span>'sword'</span><span>, </span><strong>false</strong><span>);</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(costmap), {</span><span><br></span><span>&nbsp; &nbsp; min: </span><span>0</span><span>,</span><span><br></span><span>&nbsp; &nbsp; max: </span><span>1E3</span><span><br></span><span>}, </span><span>'costmap'</span><span>, </span><strong>false</strong><span>);</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(rivermask), {}, </span><span>'rivermask'</span><span>, </span><strong>false</strong><span>);</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(channelmask), {}, </span><span>'channelmask'</span><span>, </span><strong>false</strong><span>);</span><br><br></pre>
<p><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-10-26%20at%2010.22.50%E2%80%AFAM.png" alt="screenshot of the result" loading="lazy"></p>
<p>Your code up to this point should look like this:</p>
<pre><br>var aoi =&nbsp;<br>&nbsp; &nbsp; /* color: #d63000 */<br>&nbsp; &nbsp; /* shown: false */<br>&nbsp; &nbsp; /* displayProperties: [<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; "type": "rectangle"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; ] */<br>&nbsp; &nbsp; ee.Geometry.Polygon(<br>&nbsp; &nbsp; &nbsp; &nbsp; [[[-67.18414102495456, -11.09095257894929],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-67.18414102495456, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.09095257894929]]], null, false);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>var sword = ee.FeatureCollection("projects/gee-book/assets/A2-4/SWORD");<br><br><br>var getUTMProj = function(lon, lat) {<br>&nbsp; &nbsp; // given longitude and latitude (in degree decimals) return EPSG string for the&nbsp;<br>&nbsp; &nbsp; // corresponding UTM projection<br>&nbsp; &nbsp; // see https://apollomapping.com/blog/gtm-finding-a-utm-zone-number-easily and<br>&nbsp; &nbsp; // https://sis.apache.org/faq.html<br>&nbsp; &nbsp; var utmCode = ee.Number(lon).add(180).divide(6).ceil().int();<br>&nbsp; &nbsp; var output = ee.Algorithms.If(ee.Number(lat).gte(0),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:326').cat(utmCode.format('%02d')),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:327').cat(utmCode.format('%02d')));<br>&nbsp; &nbsp; return (output);<br>};<br><br>var coords = aoi.centroid(30).coordinates();<br>var lon = coords.get(0);<br>var lat = coords.get(1);<br>var crs = getUTMProj(lon, lat);<br>var scale = ee.Number(30);<br><br>var rpj = function(image) {<br>&nbsp; &nbsp; return image.reproject({<br>&nbsp; &nbsp; &nbsp; &nbsp; crs: crs,<br>&nbsp; &nbsp; &nbsp; &nbsp; scale: scale<br>&nbsp; &nbsp; });<br>};<br><br>// IMPORT AND VISUALIZE SURFACE WATER MASK.<br>// Surface water occurrence dataset from the JRC (Pekel et al., 2016).<br>var jrcYearly = ee.ImageCollection('JRC/GSW1_3/YearlyHistory');<br><br>// Select the seasonal and permanent pixels image representing the year 2000<br>var watermask = jrcYearly.filter(ee.Filter.eq('year', 2000)).first()<br>&nbsp; &nbsp; .gte(2).unmask(0)<br>&nbsp; &nbsp; .clip(aoi);<br><br>Map.centerObject(aoi);<br>Map.addLayer(ee.Image.constant(0), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; palette: ['black']<br>}, 'bg', false);<br>Map.addLayer(watermask, {}, 'watermask', false);<br><br>// REMOVE NOISE AND SMALL ISLANDS TO SIMPLIFY THE TOPOLOGY.<br><br>// a. Image closure operation to fill small holes.<br>watermask = watermask.focal_max().focal_min();<br><br>// b. Identify small bars and fill them in to create a filled water mask.<br>var MIN_SIZE = 2E3;<br>var barPolys = watermask.not().selfMask()<br>&nbsp; &nbsp; .reduceToVectors({<br>&nbsp; &nbsp; &nbsp; &nbsp; geometry: aoi,<br>&nbsp; &nbsp; &nbsp; &nbsp; scale: 30,<br>&nbsp; &nbsp; &nbsp; &nbsp; eightConnected: true<br>&nbsp; &nbsp; })<br>&nbsp; &nbsp; .filter(ee.Filter.lte('count', MIN_SIZE)); // Get small polys.<br>var filled = watermask.paint(barPolys, 1);<br><br>Map.addLayer(rpj(filled), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 1<br>}, 'filled water mask', false);<br><br>// IDENTIFYING RIVERS FROM OTHER TYPES OF WATER BODIES.<br>// Cumulative cost mapping to find pixels connected to a reference centerline.<br>var costmap = filled.not().cumulativeCost({<br>&nbsp; &nbsp; source: watermask.and(ee.Image().toByte().paint(sword,<br>&nbsp; &nbsp; &nbsp; &nbsp; 1)),<br>&nbsp; &nbsp; maxDistance: 3E3,<br>&nbsp; &nbsp; geodeticDistance: false<br>});<br><br>var rivermask = costmap.eq(0).rename('riverMask');<br>var channelmask = rivermask.and(watermask);<br><br>Map.addLayer(sword, {<br>&nbsp; &nbsp; color: 'red'<br>}, 'sword', false);<br>Map.addLayer(rpj(costmap), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 1E3<br>}, 'costmap', false);<br>Map.addLayer(rpj(rivermask), {}, 'rivermask', false);<br>Map.addLayer(rpj(channelmask), {}, 'channelmask', false);</pre>
</body>
</html>