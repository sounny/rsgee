<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>RS3 - 4 - Defining Urban and Rural References</title>
<meta name="identifier" content="g6691711c3717d62cfe668c68ed09f96d"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
</head>
<body>
<p><span>Now that we have estimates of LST using various products and algorithms, we can calculate the rural LST and subtract it from the urban LST to get the SUHI intensity. There are many ways to estimate the rural reference temperature (Li et al. 2022), and we will explore a few of them in this section.</span></p>
<p><span>The simplest and most commonly used method to get the rural reference when calculating the SUHI is to generate a buffered area around the urban boundary. The exact width of the buffer varies across studies, with buffers of 2–30 km in width being used in previous studies (Clinton and Gong 2013, Venter et al. 2021, Yao et al. 2019). In Earth Engine, generating such a buffer is simple:</span></p>
<table>
<tbody>
<tr>
<td>
<pre><span>// Function to subtract the original urban cluster from the buffered cluster </span><span><br></span><span>// to generate rural references.</span><span><br></span><strong>function</strong><span> bufferSubtract(feature) {</span><span><br></span><span>&nbsp; &nbsp; </span><strong>return</strong><span> </span><span>ee</span><span>.</span><span>Feature</span><span>(feature.</span><span>geometry</span><span>()</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; .</span><span>buffer</span><span>(</span><span>2000</span><span>)</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; .</span><span>difference</span><span>(feature.</span><span>geometry</span><span>()));</span><span><br></span><span>}</span><span><br></span><span><br></span><strong>var</strong><span> ruralRef = regionInt.</span><span>map</span><span>(bufferSubtract);</span><span><br></span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(ruralRef, {</span><span><br></span><span>&nbsp; &nbsp; color: </span><span>'green'</span><span><br></span><span>}, </span><span>'Buffer_ref'</span><span>);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span>In the script above, a buffered polygon with a 2 km width is generated around the urban boundary, and the original urban boundary is subtracted from the buffered polygon.&nbsp;</span></p>
<p><span><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-11-09%20at%2011.29.00%E2%80%AFAM.png" alt="Screenshot 2023-11-09 at 11.29.00 AM.png" loading="lazy"></span></p>
<p><em><strong>Figure</strong><span> A 2 km buffer around the original city boundary to serve as the rural reference</span></em></p>
<p><span>Using a constant buffer assumes that all urban areas, regardless of size, have a similar influence around the city. This may be different for large cities. There is some evidence that there is a footprint of the SUHI that is dependent on the size of the city (Yang et al. 2019, Zhou et al. 2015). As such, another way to define the buffered region is to normalize its area by the area of the urban cluster it surrounds (Chakraborty et al. 2021b, Peng et al. 2011). An iterative method is one way to do so in Earth Engine. This method (see code block below) uses functions first to calculate buffers of different widths around a geometry and then select the buffered region that is closest in size to the original geometry.</span></p>
<table>
<tbody>
<tr>
<td>
<pre><span>// Define sequence of buffer widths to be tested.</span><span><br></span><strong>var</strong><span> buffWidths = </span><span>ee</span><span>.</span><span>List.sequence</span><span>(</span><span>30</span><span>, </span><span>3000</span><span>, </span><span>30</span><span>);</span><span><br></span><span><br></span><span>// Function to generate standardized buffers (approximately comparable to area of urban cluster).</span><span><br></span><strong>function</strong><span> bufferOptimize(feature) {</span><span><br></span><span>&nbsp; &nbsp; </span><strong>function</strong><span> buff(buffLength) {</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><strong>var</strong><span> buffedPolygon = </span><span>ee</span><span>.</span><span>Feature</span><span>(feature.</span><span>geometry</span><span>()</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .</span><span>buffer</span><span>(</span><span>ee</span><span>.</span><span>Number</span><span>(buffLength)))</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .</span><span>set</span><span>({</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Buffer_width'</span><span>: </span><span>ee</span><span>.</span><span>Number</span><span>(buffLength)</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><strong>var</strong><span> area = buffedPolygon.</span><span>geometry</span><span>().</span><span>difference</span><span>(feature</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .</span><span>geometry</span><span>()).</span><span>area</span><span>();</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><strong>var</strong><span> diffFeature = </span><span>ee</span><span>.</span><span>Feature</span><span>(</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffedPolygon.</span><span>geometry</span><span>().</span><span>difference</span><span>(feature</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .</span><span>geometry</span><span>()));</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><strong>return</strong><span> diffFeature.</span><span>set</span><span>({</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Buffer_diff'</span><span>: area.</span><span>subtract</span><span>(feature.</span><span>geometry</span><span>()</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .</span><span>area</span><span>()).</span><span>abs</span><span>(),</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Buffer_area'</span><span>: area,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Buffer_width'</span><span>: buffedPolygon.</span><span>get</span><span>(</span><span>'Buffer_width'</span><span>)</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; });</span><span><br></span><span>&nbsp; &nbsp; }</span><span><br></span><span><br></span><span>&nbsp; &nbsp; </span><strong>var</strong><span> buffed = </span><span>ee</span><span>.</span><span>FeatureCollection</span><span>(buffWidths.</span><span>map</span><span>(buff));</span><span><br></span><span>&nbsp; &nbsp; </span><strong>var</strong><span> sortedByBuffer = buffed.</span><span>sort</span><span>({</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; property: </span><span>'Buffer_diff'</span><span><br></span><span>&nbsp; &nbsp; });</span><span><br></span><span>&nbsp; &nbsp; </span><strong>var</strong><span> firstFeature = </span><span>ee</span><span>.</span><span>Feature</span><span>(sortedByBuffer.</span><span>first</span><span>());</span><span><br></span><span>&nbsp; &nbsp; </span><strong>return</strong><span> firstFeature.</span><span>set</span><span>({</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Urban_Area'</span><span>: feature.</span><span>get</span><span>(</span><span>'Area'</span><span>),</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'Buffer_width'</span><span>: firstFeature.</span><span>get</span><span>(</span><span>'Buffer_width'</span><span>)</span><span><br></span><span>&nbsp; &nbsp; });</span><span><br></span><span>}</span><span><br></span><span><br></span><span>// Map function over urban feature collection.</span><span><br></span><strong>var</strong><span> ruralRefStd = regionInt.</span><span>map</span><span>(bufferOptimize);</span><span><br></span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(ruralRefStd, {</span><span><br></span><span>&nbsp; &nbsp; color: </span><span>'brown'</span><span><br></span><span>}, </span><span>'Buffer_ref_std'</span><span>);</span><span><br></span><span><br></span><span>print</span><span>(</span><span>'ruralRefStd'</span><span>, ruralRefStd);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span>Note how mapping the </span><span>buff</span><span> function over a sequence of pre-defined values, as done here, does not require loops, which are best avoided when using Earth Engine The same is true of mapping the </span><span>bufferOptimize</span><span> function: here it is mapped over a </span><span>FeatureCollection</span><span> with a single feature, but it would work even if </span><span>regionInt</span><span> contained multiple features. In this way, nested </span><span>map</span><span> functions in Earth Engine have the utility of nested loops in other languages.</span><span><br></span></p>
<p><span>Check the printed value on the </span><strong>Console</strong><span>. According to the result, within an uncertainty of 30 m, a buffer of 1170 m in width creates a polygon that is roughly equal to the area of the city. This function is best run via export when working with large feature collections.&nbsp;&nbsp;</span></p>
<p><span>The final way to define a rural reference does not use a buffer at all, but relies on land cover classes to select pixels that are urban versus non-urban (Chakraborty et al. 2020, Chakraborty and Lee 2019). For this, we will rely on the NLCD 2016 land cover data (Wickham et al. 2021) and create masks for urban and non-urban pixels (Fig. A1.5.10).</span></p>
<table>
<tbody>
<tr>
<td>
<pre><span>// Select the NLCD land cover data.</span><span><br></span><strong>var</strong><span> landCover = </span><span>ee</span><span>.</span><span>Image</span><span>(</span><span>'USGS/NLCD/NLCD2016'</span><span>).</span><span>select</span><span>(</span><span>'landcover'</span><span>);</span><span><br></span><strong>var</strong><span> urban = landCover;</span><span><br></span><span><br></span><span>// Select urban pixels in image.</span><span><br></span><strong>var</strong><span> urbanUrban = urban.</span><span>updateMask</span><span>(urban.</span><span>eq</span><span>(</span><span>23</span><span>).</span><span>or</span><span>(urban.</span><span>eq</span><span>(</span><span>24</span><span>)));</span><span><br></span><span><br></span><span>// Select background reference pixels in the image.</span><span><br></span><strong>var</strong><span> nonUrbanVals = [</span><span>41</span><span>, </span><span>42</span><span>, </span><span>43</span><span>, </span><span>51</span><span>, </span><span>52</span><span>, </span><span>71</span><span>, </span><span>72</span><span>, </span><span>73</span><span>, </span><span>74</span><span>, </span><span>81</span><span>, </span><span>82</span><span>];</span><span><br></span><strong>var</strong><span> nonUrbanPixels = urban.</span><span>eq</span><span>(</span><span>ee</span><span>.</span><span>Image</span><span>(nonUrbanVals)).</span><span>reduce</span><span>(</span><span>'max'</span><span>);</span><span><br></span><strong>var</strong><span> urbanNonUrban = urban.</span><span>updateMask</span><span>(nonUrbanPixels);</span><span><br></span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(urbanUrban.</span><span>clip</span><span>(regionInt), {</span><span><br></span><span>&nbsp; &nbsp; palette: </span><span>'red'</span><span><br></span><span>}, </span><span>'Urban pixels'</span><span>);</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(urbanNonUrban.</span><span>clip</span><span>(regionInt), {</span><span><br></span><span>&nbsp; &nbsp; palette: </span><span>'blue'</span><span><br></span><span>}, </span><span>'Non-urban pixels'</span><span>);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-11-09%20at%2011.31.10%E2%80%AFAM.png" alt="Screenshot 2023-11-09 at 11.31.10 AM.png" loading="lazy"></p>
<p><em>Figure<span> Urban (red) and rural (blue) pixels in New Haven, Connecticut</span></em></p>
<p><span>Subsequently, We can use these as masks to select urban versus rural LST pixels. You will find more about this in the next section.</span></p>
</body>
</html>