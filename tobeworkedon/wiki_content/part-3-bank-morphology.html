<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Part 3 - Bank Morphology</title>
<meta name="identifier" content="g7dfc0ebd37f13848b4d86bdd35b2467c"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
</head>
<body>
<p><span>In addition to a river’s centerline and width, we can also extract information about the banks of the river, such as their aspect and total length. To identify the banks, we simply dilate the channel mask and compare it to the original channel mask. These images' differences represent the land pixels adjacent to the channel mask.&nbsp;</span></p>
<table>
<tbody>
<tr>
<td>
<pre><strong>var</strong><span> bankMask = channelmask.</span><span>focal_max</span><span>(</span><span>1</span><span>).</span><span>neq</span><span>(channelmask);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span>Next, we will calculate the aspect, or compass direction, of the bank faces. We use the </span><span>Image</span><span>.</span><span>cumulativeCost</span> <span>method with the entire river channel as our source to create a new image (bankDistance) with increasing values away from the river channel, similar to an elevation map of river banks. In this image, the banks will ‘slope’ towards the river channel and we can take advantage of the terrain methods in EE. We will call the</span> <span>Terrain.aspect</span> <span>method on the bank distance and select the bank pixels by applying the bank mask. In the end, our bank aspect data will give us the direction from each bank pixel towards the center of the channel. These data could be useful for interpreting any directional preferences in erosion as a result of geological features or thawed permafrost soils from solar radiation.</span></p>
<table>
<tbody>
<tr>
<td>
<pre><strong>var</strong><span> bankDistance = channelmask.</span><span>not</span><span>().</span><span>cumulativeCost</span><span>({</span><span><br></span><span>&nbsp; &nbsp; source: channelmask,</span><span><br></span><span>&nbsp; &nbsp; maxDistance: </span><span>1E2</span><span>,</span><span><br></span><span>&nbsp; &nbsp; geodeticDistance: </span><strong>false</strong><span><br></span><span>});</span><span><br></span><span><br></span><strong>var</strong><span> bankAspect = </span><span>ee</span><span>.</span><span>Terrain.aspect</span><span>(bankDistance)</span><span><br></span><span>&nbsp; &nbsp; .</span><span>multiply</span><span>(Math.PI)</span><span>.divide</span><span>(</span><span>180</span><span>)</span><span><br></span><span>&nbsp; &nbsp; .</span><span>mask</span><span>(bankMask).</span><span>rename</span><span>(</span><span>'bankAspect'</span><span>);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span>Last, we calculate the length represented by each bank pixel by convolving the bank mask with a Euclidean distance kernel. Sections of bank oriented along the pixel edges will have a value of 30 m per pixel, whereas a diagonal section will have a value of </span><span>2</span><span> * 30 m per pixel.&nbsp;</span></p>
<p>&nbsp;</p>
<table>
<tbody>
<tr>
<td>
<pre><strong>var</strong><span> distanceKernel = </span><span>ee</span><span>.</span><span>Kernel.euclidean</span><span>({</span><span><br></span><span>&nbsp; &nbsp; radius: </span><span>30</span><span>,</span><span><br></span><span>&nbsp; &nbsp; units: </span><span>'meters'</span><span>,</span><span><br></span><span>&nbsp; &nbsp; magnitude: </span><span>0.5</span><span><br></span><span>});</span><span><br></span><strong>var</strong><span> bankLength = bankMask.</span><span>convolve</span><span>(distanceKernel)</span><span><br></span><span>&nbsp; &nbsp; .</span><span>mask</span><span>(bankMask).</span><span>rename</span><span>(</span><span>'bankLength'</span><span>);</span><span><br></span><span><br></span><strong>var</strong><span> radianVis = {</span><span><br></span><span>&nbsp; &nbsp; min: </span><span>0</span><span>,</span><span><br></span><span>&nbsp; &nbsp; max: </span><span>2</span><span> * Math.PI,</span><span><br></span><span>&nbsp; &nbsp; </span><span>palette: [</span><span>'red'</span><span>, </span><span>'yellow'</span><span>, </span><span>'green'</span><span>, </span><span>'teal'</span><span>, </span><span>'blue'</span><span>, </span><span>'magenta'</span><span>,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'red'</span><span><br></span><span>&nbsp; &nbsp; ]</span><span><br></span><span>};</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(bankAspect), radianVis, </span><span>'bank aspect'</span><span>, </span><strong>false</strong><span>);</span><span><br></span><span>Map</span><span>.</span><span>addLayer</span><span>(rpj(bankLength), {</span><span><br></span><span>&nbsp; &nbsp; min: </span><span>0</span><span>,</span><span><br></span><span>&nbsp; &nbsp; max: </span><span>60</span><span><br></span><span>}, </span><span>'bank length'</span><span>, </span><strong>false</strong><span>);</span></pre>
</td>
</tr>
</tbody>
</table>
<p><img src="$IMS-CC-FILEBASE$/Uploaded%20Media/Screenshot%202023-10-26%20at%2011.08.38%E2%80%AFAM.png" alt="screenshot of results" loading="lazy"></p>
<p>This is what your code should look like now:</p>
<pre><br>var aoi =&nbsp;<br>&nbsp; &nbsp; /* color: #d63000 */<br>&nbsp; &nbsp; /* shown: false */<br>&nbsp; &nbsp; /* displayProperties: [<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; "type": "rectangle"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; ] */<br>&nbsp; &nbsp; ee.Geometry.Polygon(<br>&nbsp; &nbsp; &nbsp; &nbsp; [[[-67.18414102495456, -11.09095257894929],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-67.18414102495456, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.402427204567534],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [-66.57886300981784, -11.09095257894929]]], null, false);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>var sword = ee.FeatureCollection("projects/gee-book/assets/A2-4/SWORD");<br><br><br>var getUTMProj = function(lon, lat) {<br>&nbsp; &nbsp; // given longitude and latitude (in degree decimals) return EPSG string for the&nbsp;<br>&nbsp; &nbsp; // corresponding UTM projection<br>&nbsp; &nbsp; // see https://apollomapping.com/blog/gtm-finding-a-utm-zone-number-easily and<br>&nbsp; &nbsp; // https://sis.apache.org/faq.html<br>&nbsp; &nbsp; var utmCode = ee.Number(lon).add(180).divide(6).ceil().int();<br>&nbsp; &nbsp; var output = ee.Algorithms.If(ee.Number(lat).gte(0),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:326').cat(utmCode.format('%02d')),<br>&nbsp; &nbsp; &nbsp; &nbsp; ee.String('EPSG:327').cat(utmCode.format('%02d')));<br>&nbsp; &nbsp; return (output);<br>};<br><br>var coords = aoi.centroid(30).coordinates();<br>var lon = coords.get(0);<br>var lat = coords.get(1);<br>var crs = getUTMProj(lon, lat);<br>var scale = ee.Number(30);<br><br>var rpj = function(image) {<br>&nbsp; &nbsp; return image.reproject({<br>&nbsp; &nbsp; &nbsp; &nbsp; crs: crs,<br>&nbsp; &nbsp; &nbsp; &nbsp; scale: scale<br>&nbsp; &nbsp; });<br>};<br><br>// IMPORT AND VISUALIZE SURFACE WATER MASK.<br>// Surface water occurrence dataset from the JRC (Pekel et al., 2016).<br>var jrcYearly = ee.ImageCollection('JRC/GSW1_3/YearlyHistory');<br><br>// Select the seasonal and permanent pixels image representing the year 2000<br>var watermask = jrcYearly.filter(ee.Filter.eq('year', 2000)).first()<br>&nbsp; &nbsp; .gte(2).unmask(0)<br>&nbsp; &nbsp; .clip(aoi);<br><br>Map.centerObject(aoi);<br>Map.addLayer(ee.Image.constant(0), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; palette: ['black']<br>}, 'bg', false);<br>Map.addLayer(watermask, {}, 'watermask', false);<br><br>// REMOVE NOISE AND SMALL ISLANDS TO SIMPLIFY THE TOPOLOGY.<br><br>// a. Image closure operation to fill small holes.<br>watermask = watermask.focal_max().focal_min();<br><br>// b. Identify small bars and fill them in to create a filled water mask.<br>var MIN_SIZE = 2E3;<br>var barPolys = watermask.not().selfMask()<br>&nbsp; &nbsp; .reduceToVectors({<br>&nbsp; &nbsp; &nbsp; &nbsp; geometry: aoi,<br>&nbsp; &nbsp; &nbsp; &nbsp; scale: 30,<br>&nbsp; &nbsp; &nbsp; &nbsp; eightConnected: true<br>&nbsp; &nbsp; })<br>&nbsp; &nbsp; .filter(ee.Filter.lte('count', MIN_SIZE)); // Get small polys.<br>var filled = watermask.paint(barPolys, 1);<br><br>Map.addLayer(rpj(filled), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 1<br>}, 'filled water mask', false);<br><br>// IDENTIFYING RIVERS FROM OTHER TYPES OF WATER BODIES.<br>// Cumulative cost mapping to find pixels connected to a reference centerline.<br>var costmap = filled.not().cumulativeCost({<br>&nbsp; &nbsp; source: watermask.and(ee.Image().toByte().paint(sword,<br>&nbsp; &nbsp; &nbsp; &nbsp; 1)),<br>&nbsp; &nbsp; maxDistance: 3E3,<br>&nbsp; &nbsp; geodeticDistance: false<br>});<br><br>var rivermask = costmap.eq(0).rename('riverMask');<br>var channelmask = rivermask.and(watermask);<br><br>Map.addLayer(sword, {<br>&nbsp; &nbsp; color: 'red'<br>}, 'sword', false);<br>Map.addLayer(rpj(costmap), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 1E3<br>}, 'costmap', false);<br>Map.addLayer(rpj(rivermask), {}, 'rivermask', false);<br>Map.addLayer(rpj(channelmask), {}, 'channelmask', false);<br><br>// Import existing functions from RivWidthCloud.<br>var riverFunctions = require(<br>&nbsp; &nbsp; 'users/eeProject/RivWidthCloudPaper:functions_river.js');<br>var clFunctions = require(<br>&nbsp; &nbsp; 'users/eeProject/RivWidthCloudPaper:functions_centerline_width.js'<br>&nbsp; &nbsp; );<br><br>//Calculate distance from shoreline using distance transform.<br><br>var distance = clFunctions.CalcDistanceMap(rivermask, 256, scale);<br>Map.addLayer(rpj(distance), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 500<br>}, 'distance raster', false);<br><br>// Calculate gradient of the distance raster.<br>// There are three different ways (kernels) to calculate the gradient.&nbsp;<br>// By default, the function used the second approach.&nbsp;<br>// For details on the kernels, please see the source code for this function.<br>var gradient = clFunctions.CalcGradientMap(distance, 2, scale);<br>Map.addLayer(rpj(gradient), {}, 'gradient raster', false);<br><br>// Threshold the gradient raster and derive 1px width centerline using skeletonization.<br><br>var centerlineRaw = clFunctions.CalcOnePixelWidthCenterline(rivermask,<br>&nbsp; &nbsp; gradient, 0.9);<br>var raw1pxCenterline = rpj(centerlineRaw).eq(1).selfMask();<br>Map.addLayer(raw1pxCenterline, {<br>&nbsp; &nbsp; palette: ['red']<br>}, 'raw 1px centerline', false);<br><br>// Prune the centerline to remove spurious branches.<br>var MAXDISTANCE_BRANCH_REMOVAL = 500;<br>// Note: the last argument of the CleanCenterline function enables removal of the pixels so that the resulting centerline will have 1px width in an 8-connected way. Once it is done, it doesn’t need to be done the second time (thus it equals false)<br>var cl1px = clFunctions<br>&nbsp; &nbsp; .CleanCenterline(centerlineRaw, MAXDISTANCE_BRANCH_REMOVAL, true);<br>var cl1px = clFunctions<br>&nbsp; &nbsp; .CleanCenterline(cl1px, MAXDISTANCE_BRANCH_REMOVAL, false);<br>var final1pxCenterline = rpj(cl1px).eq(1).selfMask();<br>Map.addLayer(final1pxCenterline, {<br>&nbsp; &nbsp; palette: ['red']<br>}, 'final 1px centerline', false);<br><br>// Calculate perpendicular direction for the cleaned centerline.<br>var angle = clFunctions.CalculateAngle(cl1px);<br>var angleVis = {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 360,<br>&nbsp; &nbsp; palette: ['#ffffd4', '#fed98e', '#fe9929', '#d95f0e',<br>&nbsp; &nbsp; &nbsp; &nbsp; '#993404'<br>&nbsp; &nbsp; ]<br>};<br>Map.addLayer(rpj(angle), angleVis, 'cross-sectional directions',<br>&nbsp; &nbsp; false);<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; // Estimate width.<br>var rwcFunction = require(<br>&nbsp; &nbsp; 'users/eeProject/RivWidthCloudPaper:rwc_watermask.js');<br>var rwc = rwcFunction.rwGen_waterMask(4000, 333, 500, aoi);<br>watermask = ee.Image(watermask.rename(['waterMask']).setMulti({<br>&nbsp; &nbsp; crs: crs,<br>&nbsp; &nbsp; scale: 30,<br>&nbsp; &nbsp; image_id: 'aoi'<br>}));<br><br>var widths = rwc(watermask);<br>print('example width output', widths.first());<br><br>var bankMask = channelmask.focal_max(1).neq(channelmask);<br><br>var bankDistance = channelmask.not().cumulativeCost({<br>&nbsp; &nbsp; source: channelmask,<br>&nbsp; &nbsp; maxDistance: 1E2,<br>&nbsp; &nbsp; geodeticDistance: false<br>});<br><br>var bankAspect = ee.Terrain.aspect(bankDistance)<br>&nbsp; &nbsp; .multiply(Math.PI).divide(180)<br>&nbsp; &nbsp; .mask(bankMask).rename('bankAspect');<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; var distanceKernel = ee.Kernel.euclidean({<br>&nbsp; &nbsp; radius: 30,<br>&nbsp; &nbsp; units: 'meters',<br>&nbsp; &nbsp; magnitude: 0.5<br>});<br>var bankLength = bankMask.convolve(distanceKernel)<br>&nbsp; &nbsp; .mask(bankMask).rename('bankLength');<br><br>var radianVis = {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 2 * Math.PI,<br>&nbsp; &nbsp; palette: ['red', 'yellow', 'green', 'teal', 'blue', 'magenta',<br>&nbsp; &nbsp; &nbsp; &nbsp; 'red'<br>&nbsp; &nbsp; ]<br>};<br>Map.addLayer(rpj(bankAspect), radianVis, 'bank aspect', false);<br>Map.addLayer(rpj(bankLength), {<br>&nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; max: 60<br>}, 'bank length', false);</pre>
</body>
</html>