<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>GSO-7-CalculateSnowCoverFrequency</title>
<meta name="identifier" content="gc4535f25ac7607fd24d65f5b0d4d84c3"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
</head>
<body>
<p><span dir="ltr"><span>Our dataset is now ready to be analyzed. &nbsp;We have an image collection of images that have a single band, called remapped, that represents a sensor-adjusted and reclassified snow cover for each day of the collection. &nbsp;Snow cover frequency is the number of days with a snow observation divided by the number of days with a valid observation. &nbsp;So, we need to count the number of times a snow value appears and the number of times a snow or land value appears. &nbsp;After calculating snow cover frequency, that information needs to be added to an image as a band, along with a constant time value, so that we can hand that to the reducer as discussed in the Outline and Goals section. &nbsp;</span></span></p>
<div><span><strong>About Reducers</strong></span></div>
<div><span><a class="external" href="https://sites.google.com/site/earthengineapidocs/basic-image-manipulation/image-collections/reducing-images" target="_blank">Reducers&nbsp;<span class="external_link_icon" role="presentation"><span class="screenreader-only">Links to an external site.</span></span></a>are a special method that usually doesn't take an input argument. &nbsp;They instead act at each pixel stack in an imageCollection and calculate a specific&nbsp;property of that stack, returning an image. &nbsp;If you think back to our reclassification scheme, pixels with snow have a value of 1, pixels with a valid observation have a value of 0, and all other&nbsp;pixels&nbsp;have a value of&nbsp;<i>null. &nbsp;</i>In&nbsp;order&nbsp;to calculate snow cover&nbsp;frequency, we need to know both the number of snow days and the number of valid days. &nbsp;</span><span>Luckily, GEE has just the methods for this. &nbsp;The .count() method will count the number of times a pixel has a valid value within an imageCollection and will ignore (not count) those images that have a “masked” value so that it will count both snow and no snow values in a pixel stack.</span><span>&nbsp; We can also count the number of snow days at a pixel directly by using the .sum() method, which adds the values in that stack of pixels. &nbsp;We also want to wrap this up in its own function. &nbsp;The code to do so appears as follows...</span></div>
<div><span><br></span>
<div>
<div>
<pre>// A function to merge the bands together after a join<br>// the bands are referred to as the 'primary' and 'secondary' properties<br>var MergeBands = function(aRow) {<br>&nbsp; var anImage = ee.Image.cat(aRow.get('primary'), aRow.get('secondary'));<br>&nbsp; return anImage;<br>};<br><br><br>// A function to assign high sensor zenith angle cells to null<br>var CorrectSensorPixels = function(anImage) {<br>&nbsp; var LT25 = anImage.select('SensorZenith').lte(2500); // Angle is stored as angle * 100 in MOD09<br>&nbsp; return anImage.mask(LT25);<br>};<br><br>// A function to reclassify MODIS snow cover products (MOD10A1/A2) values<br>// snow/ice--1; no snow/ice--0; all others--null<br>var Reclassify = function(anImage) {<br>&nbsp; var ClassifiedImage = anImage.remap([100, 200, &nbsp;25, &nbsp;37, &nbsp;39], &nbsp; // Original pixel values from MODIS Snow Products<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ &nbsp;1, &nbsp; 1, &nbsp; 0, &nbsp; 0, &nbsp; 0], &nbsp; // Reclassified values: 1--snow/ice; 0--no snow/ice<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// All other MODIS snow product pixel values (0, 1, 11, 50, 254, 255)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Snow_Cover_Daily_Tile'); &nbsp; &nbsp;// The band we wish to remap<br>&nbsp; return ClassifiedImage;<br>};<br><br><br>// Prepare MODIS snow cover data for calculating snow cover frequency<br>// Join MOD09 and MOD10, mask out cells with gte 25 sensor-zenith-angle, and reclassify to: 1, 0, null<br>var PrepareModisSnowCover = function(StartDate, EndDate) {<br>&nbsp; // Create MOD09GA and MOD10A1 image collections for the time period<br>&nbsp; var MOD09GA = ee.ImageCollection('MOD09GA').select('SensorZenith')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.filterDate(StartDate, EndDate);<br>&nbsp; var MOD10A1 = ee.ImageCollection('MOD10A1').select('Snow_Cover_Daily_Tile')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filterDate(StartDate, EndDate);<br>&nbsp;&nbsp;<br>&nbsp; // Define the join type and filter<br>&nbsp; var innerJoin = ee.Join.inner();<br>&nbsp; var joinFilter = ee.Filter.equals({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'leftField': 'system:time_start',&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'rightField': 'system:time_start'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br><br>&nbsp; // Join the two collections, passing entries through the filter<br>&nbsp; var joinedMods = ee.ImageCollection(innerJoin.apply(MOD09GA, MOD10A1, joinFilter));<br><br>&nbsp; // Map our functions over the Image Collections&nbsp;<br>&nbsp; var FinalModisDataset = joinedMods.map(MergeBands)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(CorrectSensorPixels)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(Reclassify);<br>&nbsp;&nbsp;<br>&nbsp; return FinalModisDataset;<br>};<br><br><br>var CalculateSnowCoverFrequency = function(ModisSnowCover) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// We hand the function our final MODIS dataset<br>&nbsp; var NumOfSnowDays = &nbsp;ModisSnowCover.sum(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Calculate the number of days with snow cover with .sum()<br>&nbsp; var NumOfValidObsDays = ModisSnowCover.count(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Count the number of days with a valid observation with .count()<br>&nbsp; var SnowCoverFrequency = NumOfSnowDays.divide(NumOfValidObsDays); &nbsp; &nbsp; &nbsp; &nbsp; // perform the calculation<br>&nbsp; return SnowCoverFrequency;<br>};<br><br><br></pre>
</div>
<div><a href="https://code.earthengine.google.com/fe4ee166571c488443349dbd31b59bd2" target="_blank">https://code.earthengine.google.com/fe4ee166571c488443349dbd31b59bd2</a>&nbsp;&nbsp;</div>
<span>Note that we have created two functions, a "prepare the dataset within a given time frame" function and a "calculate the snow cover frequency from a given dataset" function. &nbsp;These two functions together give us the Y axis, but we must now attach a date time stamp&nbsp;to each snow cover frequency. &nbsp;Think back to the requirements for the&nbsp;<a class="external" href="https://sites.google.com/site/globalsnowobservatory/home/Presentations-and-Tutorials/aag-workshop/tutorialgoals" target="_blank">linearFit reducer&nbsp;<span class="external_link_icon" role="presentation"><span class="screenreader-only">Links to an external site.</span></span></a>if this doesn't make&nbsp;sense.</span></div>
</div>
</body>
</html>