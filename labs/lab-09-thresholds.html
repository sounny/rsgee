<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab 9 - Thresholds | Remote Sensing Course</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../index.html">Home</a> &gt; <a href="../index.html#labs">Labs</a> &gt; Lab 9
        </nav>
        <header class="lab-header">
            <h1>Lab 9 - Thresholds</h1>
            <p><em><strong>Objective: Learn to apply thresholds and Boolean operators to create categorical classifications from continuous data.</strong></em></p>
        </header>
        <main class="lab-content">
            <section>
                <h2>Introduction</h2>
                <p>In this lab, we will extend the skills acquired in Lab 8 - Band Arithmetic - NDVI, to create categorized 
                images using logical operators based on a threshold value. After learning how to manipulate images using band 
                arithmetic to yield continuous values, such as the Normalized Difference Vegetation Index (NDVI), we will now 
                focus on categorizing these continuous values into distinct classes. Utilizing Google Earth Engine's suite of 
                Boolean and conditional operators, the lab will guide you through classifying NDVI values to distinguish between 
                vegetated and non-vegetated areas.</p>

                <p>Specifically, we will:</p>
                <ol>
                    <li>Explore the difference between continuous and categorical data, emphasizing their applications in remote sensing.</li>
                    <li>Implement a basic threshold to create a binary map separating vegetated and non-vegetated regions.</li>
                    <li>Use advanced techniques like <code>.where</code> and <code>remap</code> to create a more nuanced categorized 
                    image, distinguishing between water, non-forest, and forest areas.</li>
                </ol>
            </section>

            <section class="lab-steps">
                <h2>Background: Continuous vs. Categorical Data</h2>
                <p><strong>Continuous Data</strong>: This type of data is measured on a continuous scale and can take on any value 
                within a given range. In the context of remote sensing, NDVI is a good example of continuous data. The NDVI values 
                can range from -1 to 1, offering a high level of granularity. Statistical methods like mean, standard deviation, 
                and regression are suitable for analyzing continuous data.</p>

                <p><strong>Categorical Data</strong>: Categorical data falls into distinct categories and is often represented by 
                labels or numbers with no mathematical meaning. In remote sensing, this would involve taking continuous data like 
                NDVI and categorizing it into groups, such as "vegetated" and "non-vegetated," based on certain thresholds. 
                Frequency tables, chi-square tests, and contingency tables are used for analyzing categorical data.</p>

                <h3>Logical Operators for Categorization</h3>
                <p>We will use Google Earth Engine to implement thresholds and categorize NDVI values. Logical operators like 
                'greater than' (gt), 'less than' (lt), and 'equal to' (eq) will be employed to separate the NDVI image into two 
                categories: "no vegetation" or "vegetation." This simplification can be invaluable for certain types of analyses, 
                like determining the proportion of a city that is vegetated.</p>
            </section>

            <section class="lab-steps">
                <h2>Part 1: Creating an NDVI Image</h2>
                <p>Let's create a Sentinel-2 map of NDVI near Seattle, Washington, USA. Enter the code below in a new script.</p>

                <pre><code>// Create an NDVI image using Sentinel 2.
var seaPoint = ee.Geometry.Point(-122.2040, 47.6221);
var seaImage = ee.ImageCollection('COPERNICUS/S2')
    .filterBounds(seaPoint)
    .filterDate('2020-08-15', '2020-10-01')
    .first();

var seaNDVI = seaImage.normalizedDifference(['B8', 'B4']);

// And map it.
Map.centerObject(seaPoint, 10);
var vegPalette = ['red', 'white', 'green'];
Map.addLayer(seaNDVI,
    {
        min: -1,
        max: 1,
        palette: vegPalette
    },
    'NDVI Seattle');</code></pre>

                <p>Inspect the image. We can see that vegetated areas are darker green while non-vegetated locations are white 
                and water is pink. If we use the Inspector to query our image, we can see that parks and other forested areas 
                have an NDVI of about 0.5. Thus, it would make sense to define areas with NDVI values greater than 0.5 as 
                forested, and those below that threshold as not forested.</p>
            </section>

            <section class="lab-steps">
                <h2>Part 2: Implementing a Threshold</h2>
                <p>Now let's define that value as a threshold and use it to threshold our vegetated areas.</p>

                <pre><code>// Implement a threshold.
var seaVeg = seaNDVI.gt(0.5);

// Map the threshold.
Map.addLayer(seaVeg,
    {
        min: 0,
        max: 1,
        palette: ['white', 'green']
    },
    'Non-forest vs. Forest');</code></pre>

                <p>The <code>gt</code> method is from the family of Boolean operators—that is, <code>gt</code> is a function that 
                performs a test in each pixel and returns the value 1 if the test evaluates to true, and 0 otherwise. Here, for 
                every pixel in the image, it tests whether the NDVI value is greater than 0.5. When this condition is met, the 
                layer <code>seaVeg</code> gets the value 1. When the condition is false, it receives the value 0.</p>

                <p>Use the <strong>Inspector</strong> tool to explore this new layer. If you click on a green location, that NDVI 
                should be greater than 0.5. If you click on a white pixel, the NDVI value should be equal to or less than 0.5.</p>

                <p>Other operators in this Boolean family include less than (<code>lt</code>), less than or equal to 
                (<code>lte</code>), equal to (<code>eq</code>), not equal to (<code>neq</code>), and greater than or equal to 
                (<code>gte</code>) and more.</p>
            </section>

            <section class="lab-steps">
                <h2>Part 3: Using .where</h2>
                <p>A binary map classifying NDVI is very useful. However, there are situations where you may want to split your 
                image into more than two bins. Earth Engine provides a tool, the <code>where</code> method, that conditionally 
                evaluates to true or false within each pixel depending on the outcome of a test. This is analogous to an 
                <em>if</em> statement seen commonly in other languages. However, we avoid using the JavaScript if statement to 
                perform this logic when programming for Earth Engine. Importantly, JavaScript <em>if</em> commands are not 
                calculated on Google's servers, and can create serious problems when running your code—in effect, the servers try 
                to ship all of the information to be executed to your own computer's browser, which is very underequipped for such 
                enormous tasks. Instead, we use the <code>where</code> clause for conditional logic.</p>

                <p>Suppose instead of splitting the forested areas from the non-forested areas in our NDVI, we want to split the 
                image into likely water, non-forested, and forested areas. We can use <code>where</code> and thresholds of -0.1 
                and 0.5. We will start by creating an image using <code>ee.Image</code>. We then clip the new image to cover the 
                same area as our <code>seaNDVI</code> layer.</p>

                <pre><code>// Implement .where.
// Create a starting image with all values = 1.
var seaWhere = ee.Image(1)
    // Use clip to constrain the size of the new image.
    .clip(seaNDVI.geometry());

// Make all NDVI values less than -0.1 equal 0.
seaWhere = seaWhere.where(seaNDVI.lte(-0.1), 0);

// Make all NDVI values greater than 0.5 equal 2.
seaWhere = seaWhere.where(seaNDVI.gte(0.5), 2);

// Map our layer that has been divided into three classes.
Map.addLayer(seaWhere,
    {
        min: 0,
        max: 2,
        palette: ['blue', 'white', 'green']
    },
    'Water, Non-forest, Forest');</code></pre>

                <p>There are a few exciting things to note about this code that you may not have seen before. First, we're not 
                defining a new variable for each <code>where</code> call. As a result, we can perform many calls without creating 
                a new variable each time and needing to keep track of them. Second, when we started the starting image, we set the 
                value to 1. This means we could easily set the bottom and top values with one <code>where</code> clause each. 
                Finally, while we did not do it here, we can combine multiple <code>where</code> clauses using <code>and</code> or 
                <code>or</code>. For example, we could identify pixels with an intermediate level of NDVI using 
                <code>seaNDVI.gte(-0.1).and(seaNDVI.lt(0.5))</code>.</p>
            </section>

            <section class="lab-steps">
                <h2>Part 4: Remapping Values</h2>
                <p>Finally, let's do some Remapping that takes specific values in an image and assigns them a different value. 
                This is particularly useful for categorical datasets. Let's use the <code>remap</code> method to change the values 
                for our <code>seaWhere</code> layer. Note that since we're changing the middle value to be the largest, we'll also 
                need to adjust our palette.</p>

                <pre><code>// Implement remapping.
// Remap the values from the seaWhere layer.
var seaRemap = seaWhere.remap([0, 1, 2], // Existing values.
    [9, 11, 10]); // Remapped values.

Map.addLayer(seaRemap,
    {
        min: 9,
        max: 11,
        palette: ['blue', 'green', 'white']
    },
    'Remapped Values');</code></pre>

                <p>Use the inspector to compare values between our original seaWhere (displayed as Water, Non-Forest, Forest) and 
                the seaRemap, marked as "Remapped Values." Click on a forested area to see that the Remapped Values should be 10, 
                instead of 2.</p>
            </section>

            <section id="submission">
                <div class="submission-box">
                    <h3>📧 Lab Submission</h3>
                    <p>Submit lab via email.</p>
                    <p><strong>Subject:</strong> <code>Lab 9 - Thresholds - [Your Name]</code></p>
                    <p><strong>Submit the URL to your code with well-commented code that explains the different aspects of this lab. (50 points)</strong></p>
                </div>
            </section>
        </main>
        <footer>
            <p><a href="lab-08-band-arithmetic-ndvi.html">← Previous Lab</a> | <a href="lab-10-challenge-mapping-urban.html">Next Lab →</a></p>
            <p><a href="../index.html">← Back to Course Home</a></p>
        </footer>
    </div>
</body>
</html>
