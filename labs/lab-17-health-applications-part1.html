<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab 17 - Health Applications Part 1 | Remote Sensing Course</title>
    <link rel="stylesheet" href="../css/style.css">
    <meta name="robots" content="index, follow">
    <meta name="description" content="Google Earth Engine lab 17: Lab 17 - Health Applications Part 1">
</head>
<body>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../index.html">Home</a> &gt; <a href="../index.html#labs">Labs</a> &gt; Lab 17
        </nav>

        <header class="lab-header">
            <h1>Lab 17 - Health Applications Part 1</h1>
        </header>

        <main class="lab-content">
<p><em><strong>This Lab is adapted from work by Dawn Nekorchuk a Ph.D. alum of UF Geography - <a href="https://geog.ufl.edu/alumni-2/nekorchuk/" target="_blank">https://geog.ufl.edu/alumni-2/nekorchuk/</a>&nbsp;</strong></em></p>
<h4><strong>Objective</strong></h4>
<p>This lab aims to demonstrate how Google Earth Engine (GEE) can be used to support the modeling and forecasting of vector-borne infectious diseases, such as malaria. In this lab, you will learn how GEE can be used to gather data for subsequent analyses outside of GEE and how the results of these analyses can then be brought back into GEE.</p>
<p>We will calculate and export data on remotely-sensed environmental variables, such as precipitation, temperature, and vegetation water index. These factors can impact mosquito life cycles, malaria parasites, and transmission dynamics. These data can then be used in R for modeling and forecasting malaria in the Amhara region of Ethiopia, using the Epidemic Prognosis Incorporating Disease and Environmental Monitoring for Integrated Assessment (EPIDEMIA) system developed by the EcoGRAPH research group at the University of Oklahoma.</p>
<h4><strong>Learning Outcomes&nbsp;</strong></h4>
<ul>
<li aria-level="1"><span>We are extracting and calculating malaria-relevant variables from existing data sets: precipitation, temperature, and wetness.</span></li>
<li aria-level="1"><span>Importing satellite data and filtering for images over a region and time period.</span></li>
<li aria-level="1"><span>Joining two data products to get additional quality information.</span></li>
<li aria-level="1">
<span>Computing zonal summaries of the calculated variables for elements in a </span><span>FeatureCollection</span><span>.</span>
</li>
</ul>
<h4><strong>Background</strong></h4>
<p><em>Vector-borne diseases</em></p>
<p><span>Vector-borne diseases cause more than 700,000 deaths annually, of which approximately 400,000 are due to malaria, a parasitic infection by </span><i><span>Anopheles</span></i><span> mosquitoes (World Health Organization 2018, 2020). The WHO estimates around 229 million clinical malaria cases worldwide in 2019 (WHO 2020). Environmental factors, including temperature, humidity, and rainfall, are known to be important determinants of malaria risk as these affect mosquito and parasite development and life cycles, including larval habitats, mosquito fecundity, growth rates, mortality, and </span><i><span>Plasmodium</span></i><span> parasite development rates within the mosquito vector (Franklinos et al. 2019, Jones 2008, Wimberly et al. 2021).&nbsp;</span></p>
<p><em><span>Remote Sensing</span></em></p>
<p><span>Data from Earth-observing satellites can be used to monitor spatial and temporal changes in environmental factors like temperature, humidity, and rainfall (Ford et al., 2009). These data can be incorporated into disease modeling, usually as lagged functions, to help develop early warning systems for forecasting outbreaks (Wimberly et al. 2021, 2022). Accurate forecasts would allow limited resources for prevention and control to be more efficiently and effectively targeted at appropriate locations and times (WHO 2018).&nbsp;</span></p>
<p><em><span>Forecasting and Impact of Cloud-Based Remote Sensing</span></em></p>
<p><span>To implement near-real-time forecasting, meteorological and climatic data must be acquired, processed, and integrated regularly and frequently. Over the past ten years, the Epidemic Prognosis Incorporating Disease and Environmental Monitoring for Integrated Assessment (EPIDEMIA) project has developed and tested a malaria forecasting system that integrates public health surveillance with monitoring environmental and climate conditions. Since 2018 the environmental data has been acquired using Earth Engine scripts and apps (Wimberly et al. 2022). In 2019 a local team at Bahir Dar University in Ethiopia had been using EPIDEMIA with near-real-time epidemiological data to generate weekly malaria early warning reports in the Amhara region of Ethiopia.</span></p>
<p><em><span>Climate Change</span></em></p>
<p><span>In this example, we look at near-real-time environmental conditions affecting disease vectors and human transmission dynamics. On longer time scales, climate change can alter vector-borne disease transmission cycles and the geographic distributions of various vector and host species (Franklinos 2019). Health applications involving Earth Engine data likely align with a One Health approach to complex health issues. Under One Health, a core assumption is that environmental, animal, and human health are inextricably linked (Mackenzie and Jeggo 2019).&nbsp;</span></p>
<h4><strong>Part 1 - Getting the base Data into GEE</strong></h4>
<p><span>Start up your Earth Engine Code Editor by visiting <a href="https://code.earthengine.google.com/" target="_blank">https://code.earthengine.google.com/</a> and signing in.&nbsp;</span></p>
<p>To start, we must import the data we will be working with. The first item is an external asset of our study area—these are woredas in the Amhara region of Ethiopia. A woreda is an administrative division of Ethiopia, roughly equivalent to a county in the United States. The woredas are subdivided into kebeles, roughly equivalent to municipalities or townships. Isn't Geography Fun?</p>
<p>To do this, copy and paste the following code.</p>
<pre>//import data<br>var woredas = ee.FeatureCollection("users/sounny/amhara_woredas_20170207");<br><br>// Create region outer boundary to filter products on.<br>var amhara = woredas.geometry().bounds();<br><br></pre>
<p>The first line of code imports a feature collection of woredas in the Amhara region of Ethiopia from the user "sounny". The second line of code creates a boundary for the region of Amhara by calling the <code>.geometry()</code> method on the <code>woredas</code> feature collection and then calling the <code>.bounds()</code> method on the resulting geometry.</p>
<p>The <code>.geometry()</code> method returns the geometry of the feature collection. The <code>.bounds()</code> method returns the bounds of the geometry. The bounds of geometry are the minimum and maximum coordinates of the geometry.</p>
<p>In this case, the bounds of the <code>amhara</code>&nbsp;variable will be the minimum and maximum coordinates of the woredas in the Amhara region of Ethiopia. We will use the boundary to filter remote-sensing products later on the region of Amhara.</p>
<p><span>Now we can take a look at the </span><i><span>woreda</span></i><span> boundaries by adding the following code to draw it onto the map</span></p>
<p>Copy and paste the following code next.&nbsp;</p>
<pre>// Visualize woredas with black borders and no fill.<br>// Create an empty image into which to paint the features, cast to byte.<br>var empty = ee.Image().byte();<br>// Paint all the polygon edges with the same number and width.<br>var outline = empty.paint({<br>&nbsp; &nbsp; featureCollection: woredas,<br>&nbsp; &nbsp; color: 1,<br>&nbsp; &nbsp; width: 1<br>});<br>// Add woreda boundaries to the map.<br>Map.setCenter(38, 11.5, 7);<br>Map.addLayer(outline, {<br>&nbsp; &nbsp; palette: '000000'<br>}, 'Woredas');</pre>
<p>Run your code, and you should see something similar to this.&nbsp;</p>
<p><img src="../images/canvas/Uploaded%20Media/Screenshot%202023-04-14%20at%2012.43.38%20AM.png" alt="screenshot of the asset displayed"   loading="lazy"></p>
<p><span>Now we will add in four remotely sensed data that we will be processing:&nbsp;</span></p>
<ul>
<li aria-level="1"><span>The Integrated Multi-satellite Retrievals for GPM (IMERG) rainfall estimates from Global Precipitation Measurement (GPM) v6</span></li>
<li aria-level="1"><span>Terra Land Surface Temperature and Emissivity 8-Day Global 1km</span></li>
<li aria-level="1"><span>MODIS Nadir BRDF (Bidirectional Reflectance Distribution Function) Adjusted Reflectance Daily 500m</span></li>
<li aria-level="1"><span>MODIS BRDF-Albedo Quality Daily 500m</span></li>
</ul>
<p><span>Copy and Paste the following code to your script.&nbsp;</span></p>
<pre><span>var gpm = ee.ImageCollection('NASA/GPM_L3/IMERG_V06');<br>var LSTTerra8 = ee.ImageCollection('MODIS/061/MOD11A2')<br>&nbsp; &nbsp; // Due to MCST outage, only use dates after this for this script.<br>&nbsp; &nbsp; .filterDate('2001-06-26', Date.now());<br>var brdfReflect = ee.ImageCollection('MODIS/006/MCD43A4');<br>var brdfQa = ee.ImageCollection('MODIS/006/MCD43A2');</span></pre>
<p>The first line of code loads an image collection called 'NASA/GPM_L3/IMERG_V06' and assigns it to a variable called 'gpm'. This image collection contains data from the Integrated Multi-satellitE Retrievals for GPM (IMERG) product, produced by NASA's Global Precipitation Measurement (GPM) mission. The IMERG product provides global precipitation estimates at a high spatial and temporal resolution.</p>
<p>The second line of code loads an image collection called 'MODIS/061/MOD11A2' and assigns it to a variable called 'LSTTerra8'. This image collection contains Land Surface Temperature (LST) data from the Moderate Resolution Imaging Spectroradiometer (MODIS) instrument aboard the Terra satellite. The script filters the image collection only to include dates on or after '2001-06-26' up to the current date, which is returned by the 'Date.now()' function.</p>
<p>The third line of code loads an image collection called 'MODIS/006/MCD43A4' and assigns it to a variable called 'brdfReflect'. This image collection contains Bidirectional Reflectance Distribution Function (BRDF) parameters for each pixel on Earth's surface derived from the MODIS instrument.</p>
<p>The fourth line of code loads an image collection called 'MODIS/006/MCD43A2' and assigns it to a variable called 'brdfQa'. This image collection contains the quality assurance (QA) data for the BRDF parameters in the 'brdfReflect' image collection.</p>
<p>These four image collections contain remote sensing data for precipitation, land surface temperature, and BRDF parameters, which we will use for modeling and forecasting <span>Vector-borne diseases.</span></p>
<h4><strong>Part 2 - Data Prep</strong></h4>
<p><span>Now we are ready to start prepping our data, filtering it by space and time to get the images we need to model.&nbsp; To make our life easier, we will make some variables for start and end times up front that we can modify in the future if we would like to create datasets for different periods.&nbsp;</span></p>
<p><span>Place this code at the end of tour code in the code editor.</span></p>
<pre>//////////////////////////////////////////////////////////////////<br>// Part 2: Handling of dates<br><br>// This is where we define Requested start and end dates, by making variables here we make it easier to modify in the future.<br>var reqStartDate = ee.Date('2021-10-01');<br>var reqEndDate = ee.Date('2021-11-30');</pre>
<p><span>Now Some notes about our data:</span></p>
<ul>
<li>The final script will prompt the user to input a date range for the summarized data, with an expectation for near-real-time data. However, the data products used may have varying data lags, and some data may not be available within the user-requested range. To ensure accurate naming and creation of export datasets, the latest available data date will be obtained.</li>
<li>Daily data is required, but the Land Surface Temperature (LST) data is presented in 8-day composites. Therefore, we will assign the 8-day composite value to within the specified range every eight days. This also necessitates the acquisition of the 8-day composite value that corresponds to the start date requested by the user (i.e., the previous image).</li>
</ul>
<p>Copy and paste the following code into your code editor:</p>
<pre>// Note on Land Surface Temperature (LST) Dates<br>// LST MODIS is every 8 days, and a user-requested date will likely not match.<br>// We want to get the latest previous image date,<br>// &nbsp;i.e. the date the closest, but prior to, the requested date.&nbsp;<br>// We will filter later.&nbsp;<br>// Get date of first image.<br>var LSTEarliestDate = LSTTerra8.first().date();<br>// Filter collection to dates from beginning to requested start date.&nbsp;<br>var priorLstImgCol = LSTTerra8.filterDate(LSTEarliestDate,<br>&nbsp; &nbsp; reqStartDate);<br>// Get the latest (max) date of this collection of earlier images.<br>var LSTPrevMax = priorLstImgCol.reduceColumns({<br>&nbsp; &nbsp; reducer: ee.Reducer.max(),<br>&nbsp; &nbsp; selectors: ['system:time_start']<br>});<br>var LSTStartDate = ee.Date(LSTPrevMax.get('max'));<br>print('LSTStartDate', LSTStartDate);</pre>
<p><span><span>The code calculates the latest previous LST image date. LST MODIS is every 8 days, so a user-requested date will likely not match an LST date. The code first gets the date of the first LST image. Then, it filters the LST collection to dates from the beginning to the requested start date. Next, it gets this collection's latest (max) date of earlier images. Finally, it prints the LST start date.</span></span></p>
<p><span>Now that we have the LST data let's get the Precipitation. </span></p>
<p><span>Place the following code at the end of your script</span></p>
<pre>// Last available data dates<br>// Different variables have different data lags.&nbsp;<br>// Data may not be available in user range.<br>// To prevent errors from stopping script,&nbsp;<br>// &nbsp;grab last available (if relevant) &amp; filter at end.<br><br>//Precipitation&nbsp;<br>// Calculate date of most recent measurement for gpm (of all time).<br>var gpmAllMax = gpm.reduceColumns(ee.Reducer.max(), [<br>&nbsp; &nbsp; 'system:time_start'<br>]);<br>var gpmAllEndDateTime = ee.Date(gpmAllMax.get('max'));<br>// GPM every 30 minutes, so get just date part.<br>var gpmAllEndDate = ee.Date.fromYMD({<br>&nbsp; &nbsp; year: gpmAllEndDateTime.get('year'),<br>&nbsp; &nbsp; month: gpmAllEndDateTime.get('month'),<br>&nbsp; &nbsp; day: gpmAllEndDateTime.get('day')<br>});<br><br>// If data ends before requested start, take last data date,<br>// otherwise use requested date.<br>var precipStartDate = ee.Date(gpmAllEndDate.millis()<br>&nbsp; &nbsp; .min(reqStartDate.millis()));<br>print('precipStartDate', precipStartDate);</pre>
<p><span>The code calculates the latest available precipitation date. GPM data is every 30 minutes, so the code first gets the most recent measurement date for GPM. Then, it gets just the date part of the date. Next, it checks if the data ends before the requested start date. If it does, the code takes the last data date. Otherwise, the code uses the requested date. Finally, the code prints the precipitation start date.</span></p>
<p>Now we move on to get the final BRDF data.&nbsp;</p>
<p>Place this code into your editor.&nbsp;</p>
<pre>// BRDF&nbsp;<br>// Calculate date of most recent measurement for brdf (of all time).<br>var brdfAllMax = brdfReflect.reduceColumns({<br>&nbsp; &nbsp; reducer: ee.Reducer.max(),<br>&nbsp; &nbsp; selectors: ['system:time_start']<br>});<br>var brdfAllEndDate = ee.Date(brdfAllMax.get('max'));<br>// If data ends before requested start, take last data date,<br>// otherwise use the requested date.&nbsp;<br>var brdfStartDate = ee.Date(brdfAllEndDate.millis()<br>&nbsp; &nbsp; .min(reqStartDate.millis()));<br>print('brdfStartDate', brdfStartDate);<br>print('brdfEndDate', brdfAllEndDate);</pre>
<p><span>This code works like before with Parciptiatoin. <span>The code calculates the latest available BRDF date. BRDF data is every 30 minutes, so the code first gets the most recent measurement date for BRDF. Then, it gets just the date part of the date. Next, it checks if the data ends before the requested start date. If it does, the code takes the last data date. Otherwise, the code uses the requested date. Finally, the code prints the BRDF start date and end date.</span></span></p>
<h4><strong>Part 3 - Zonal Stats on Precipitation</strong></h4>
<p><span><strong><i>Precipitation Filtering and Dates</i></strong></span></p>
<p><span>We will calculate our precipitation variable for the appropriate date range and then perform a zonal summary of our </span><i><span>woredas</span></i><span>. </span><span>Using the dates when data exists in the user-requested date range, we create a list of dates to calculate our variable.</span></p>
<p><span>Place the following code at the end of your script.&nbsp;</span></p>
<pre>// Part 3: Precipitation<br><br>// Part 3.1: Precipitation filtering and dates<br><br>// Filter gpm by date, using modified start if necessary.<br>var gpmFiltered = gpm<br>&nbsp; &nbsp; .filterDate(precipStartDate, reqEndDate.advance(1, 'day'))<br>&nbsp; &nbsp; .filterBounds(amhara)<br>&nbsp; &nbsp; .select('precipitationCal');<br><br>// Calculate date of most recent measurement for gpm&nbsp;<br>// (in the modified requested window).<br>var gpmMax = gpmFiltered.reduceColumns({<br>&nbsp; &nbsp; reducer: ee.Reducer.max(),<br>&nbsp; &nbsp; selectors: ['system:time_start']<br>});<br>var gpmEndDate = ee.Date(gpmMax.get('max'));<br>var precipEndDate = gpmEndDate;<br>print('precipEndDate ', precipEndDate);<br><br>// Create a list of dates for the precipitation time series.<br>var precipDays = precipEndDate.difference(precipStartDate, 'day');<br>var precipDatesPrep = ee.List.sequence(0, precipDays, 1);<br><br>function makePrecipDates(n) {<br>&nbsp; &nbsp; return precipStartDate.advance(n, 'day');<br>}<br>var precipDates = precipDatesPrep.map(makePrecipDates);</pre>
<h5><strong><i>Calculate Daily Precipitation</i></strong></h5>
<p><span>Now we will map a function over our filtered </span><span>FeatureCollection</span><span> (</span><span>gpmFiltered</span><span>) to calculate the total daily rainfall per day. In this product, precipitation in millimeters per hour is recorded every half hour, so we will sum the day and divide by two.&nbsp;</span></p>
<pre>// part 3.2: Calculate daily precipitation<br><br>// Function to calculate daily precipitation:<br>function calcDailyPrecip(curdate) {<br>&nbsp; &nbsp; curdate = ee.Date(curdate);<br>&nbsp; &nbsp; var curyear = curdate.get('year');<br>&nbsp; &nbsp; var curdoy = curdate.getRelative('day', 'year').add(1);<br>&nbsp; &nbsp; var totprec = gpmFiltered<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(curdate, curdate.advance(1, 'day'))<br>&nbsp; &nbsp; &nbsp; &nbsp; .select('precipitationCal')<br>&nbsp; &nbsp; &nbsp; &nbsp; .sum()<br>&nbsp; &nbsp; &nbsp; &nbsp; //every half-hour<br>&nbsp; &nbsp; &nbsp; &nbsp; .multiply(0.5)<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('totprec');<br><br>&nbsp; &nbsp; return totprec<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('doy', curdoy)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('year', curyear)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('system:time_start', curdate);<br>}<br>// Map function over list of dates.<br>var dailyPrecipExtended =<br>&nbsp; &nbsp; ee.ImageCollection.fromImages(precipDates.map(calcDailyPrecip));<br><br>// Filter back to the original user requested start date.<br>var dailyPrecip = dailyPrecipExtended<br>&nbsp; &nbsp; .filterDate(reqStartDate, precipEndDate.advance(1, 'day'));</pre>
<h5>
<strong><i>Summarize Daily Precipitation by </i></strong><strong>Woreda</strong>
</h5>
<p><span>In the last section for precipitation, we will calculate a zonal summary, a mean, of the rainfall per <i>woreda</i> and flatten it for export as a CSV.&nbsp; The final exports will be done later in the lab.&nbsp;</span></p>
<pre>// Part 3.3: Summarize daily precipitation by woreda<br><br>// Filter precip data for zonal summaries.<br>var precipSummary = dailyPrecip<br>&nbsp; &nbsp; .filterDate(reqStartDate, reqEndDate.advance(1, 'day'));<br><br>// Function to calculate zonal statistics for precipitation by woreda.<br>function sumZonalPrecip(image) {<br>&nbsp; &nbsp; // To get the doy and year,&nbsp;<br>&nbsp; &nbsp; // convert the metadata to grids and then summarize.<br>&nbsp; &nbsp; var image2 = image.addBands([<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('doy').int(),<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('year').int()<br>&nbsp; &nbsp; ]);<br>&nbsp; &nbsp; // Reduce by regions to get zonal means for each county.<br>&nbsp; &nbsp; var output = image2.select(['year', 'doy', 'totprec'])<br>&nbsp; &nbsp; &nbsp; &nbsp; .reduceRegions({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection: woredas,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reducer: ee.Reducer.mean(),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale: 1000<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; return output;<br>}<br>// Map the zonal statistics function over the filtered precip data.<br>var precipWoreda = precipSummary.map(sumZonalPrecip);<br>// Flatten the results for export.<br>var precipFlat = precipWoreda.flatten();</pre>
<h4><strong><i>Part 4 Land Surface Temperature</i></strong></h4>
<p><span>We will follow a similar pattern of steps for land surface temperatures, though first, we will calculate the variable (mean LST). Then we will calculate the daily values and summarize them by </span><i><span>woreda</span></i><span>.&nbsp;</span></p>
<h5><strong><i> Calculate LST Variables</i></strong></h5>
<p><span>We will use the daytime and nighttime observed values to calculate a mean value for the day. We will use the quality layers to mask out poor-quality pixels. Working with the bitmask below, we are taking advantage of bits 6 and 7 being at the end, so the </span><span>rightShift</span><span>(</span><span>6</span><span>)</span><span> just returns these two. Then we check if they are less than or equal to 2, meaning average LST error &lt;= 3k (see MODIS documentation for the meaning of each element in the bit sequence). For more information on how to use bitmasks in other situations. To convert the pixel values, we will use the scaling factor in the data product (0.2) and convert from Kelvin to Celsius values (−273.15).&nbsp;</span></p>
<pre>// Part 4: Land surface temperature<br><br>// Part 4.1: Calculate LST variables<br><br>// Filter Terra LST by altered LST start date.<br>// Rarely, but at the end of the year if the last image is late in the year<br>// &nbsp;with only a few days in its period, it will sometimes not grab&nbsp;<br>// &nbsp;the next image. Add extra padding to reqEndDate and<br>// &nbsp;it will be trimmed at the end.<br>var LSTFiltered = LSTTerra8<br>&nbsp; &nbsp; .filterDate(LSTStartDate, reqEndDate.advance(8, 'day'))<br>&nbsp; &nbsp; .filterBounds(amhara)<br>&nbsp; &nbsp; .select('LST_Day_1km', 'QC_Day', 'LST_Night_1km', 'QC_Night');<br><br>// Filter Terra LST by QA information.<br>function filterLstQa(image) {<br>&nbsp; &nbsp; var qaday = image.select(['QC_Day']);<br>&nbsp; &nbsp; var qanight = image.select(['QC_Night']);<br>&nbsp; &nbsp; var dayshift = qaday.rightShift(6);<br>&nbsp; &nbsp; var nightshift = qanight.rightShift(6);<br>&nbsp; &nbsp; var daymask = dayshift.lte(2);<br>&nbsp; &nbsp; var nightmask = nightshift.lte(2);<br>&nbsp; &nbsp; var outimage = ee.Image(image.select(['LST_Day_1km',<br>&nbsp; &nbsp; &nbsp; &nbsp; 'LST_Night_1km'<br>&nbsp; &nbsp; ]));<br>&nbsp; &nbsp; var outmask = ee.Image([daymask, nightmask]);<br>&nbsp; &nbsp; return outimage.updateMask(outmask);<br>}<br>var LSTFilteredQa = LSTFiltered.map(filterLstQa);<br><br>// Rescale temperature data and convert to degrees Celsius (C).<br>function rescaleLst(image) {<br>&nbsp; &nbsp; var LST_day = image.select('LST_Day_1km')<br>&nbsp; &nbsp; &nbsp; &nbsp; .multiply(0.02)<br>&nbsp; &nbsp; &nbsp; &nbsp; .subtract(273.15)<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('LST_day');<br>&nbsp; &nbsp; var LST_night = image.select('LST_Night_1km')<br>&nbsp; &nbsp; &nbsp; &nbsp; .multiply(0.02)<br>&nbsp; &nbsp; &nbsp; &nbsp; .subtract(273.15)<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('LST_night');<br>&nbsp; &nbsp; var LST_mean = image.expression(<br>&nbsp; &nbsp; &nbsp; &nbsp; '(day + night) / 2', {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'day': LST_day.select('LST_day'),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'night': LST_night.select('LST_night')<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; ).rename('LST_mean');<br>&nbsp; &nbsp; return image.addBands(LST_day)<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(LST_night)<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(LST_mean);<br>}<br>var LSTVars = LSTFilteredQa.map(rescaleLst);</pre>
<h5><strong><i>Calculate Daily LST</i></strong></h5>
<p><span>Now, using a mapped function over our filtered collection, we will calculate a daily value from the 8-day composite value by assigning each of the eight days the value of the composite. We will also filter to our user-requested dates, as data exists in that range.</span></p>
<pre>// part 4.2: Calculate daily LST<br><br>// Create list of dates for time series.<br>var LSTRange = LSTVars.reduceColumns({<br>&nbsp; &nbsp; reducer: ee.Reducer.max(),<br>&nbsp; &nbsp; selectors: ['system:time_start']<br>});<br>var LSTEndDate = ee.Date(LSTRange.get('max')).advance(7, 'day');<br>var LSTDays = LSTEndDate.difference(LSTStartDate, 'day');<br>var LSTDatesPrep = ee.List.sequence(0, LSTDays, 1);<br><br>function makeLstDates(n) {<br>&nbsp; &nbsp; return LSTStartDate.advance(n, 'day');<br>}<br>var LSTDates = LSTDatesPrep.map(makeLstDates);<br><br>// Function to calculate daily LST by assigning the 8-day composite summary&nbsp;<br>// to each day in the composite period:<br>function calcDailyLst(curdate) {<br>&nbsp; &nbsp; var curyear = ee.Date(curdate).get('year');<br>&nbsp; &nbsp; var curdoy = ee.Date(curdate).getRelative('day', 'year').add(1);<br>&nbsp; &nbsp; var moddoy = curdoy.divide(8).ceil().subtract(1).multiply(8).add(<br>&nbsp; &nbsp; &nbsp; &nbsp; 1);<br>&nbsp; &nbsp; var basedate = ee.Date.fromYMD(curyear, 1, 1);<br>&nbsp; &nbsp; var moddate = basedate.advance(moddoy.subtract(1), 'day');<br>&nbsp; &nbsp; var LST_day = LSTVars<br>&nbsp; &nbsp; &nbsp; &nbsp; .select('LST_day')<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(moddate, moddate.advance(1, 'day'))<br>&nbsp; &nbsp; &nbsp; &nbsp; .first()<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('LST_day');<br>&nbsp; &nbsp; var LST_night = LSTVars<br>&nbsp; &nbsp; &nbsp; &nbsp; .select('LST_night')<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(moddate, moddate.advance(1, 'day'))<br>&nbsp; &nbsp; &nbsp; &nbsp; .first()<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('LST_night');<br>&nbsp; &nbsp; var LST_mean = LSTVars<br>&nbsp; &nbsp; &nbsp; &nbsp; .select('LST_mean')<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(moddate, moddate.advance(1, 'day'))<br>&nbsp; &nbsp; &nbsp; &nbsp; .first()<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('LST_mean');<br>&nbsp; &nbsp; return LST_day<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(LST_night)<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(LST_mean)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('doy', curdoy)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('year', curyear)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('system:time_start', curdate);<br>}<br>// Map the function over the image collection<br>var dailyLstExtended =<br>&nbsp; &nbsp; ee.ImageCollection.fromImages(LSTDates.map(calcDailyLst));<br><br>// Filter back to original user requested start date<br>var dailyLst = dailyLstExtended<br>&nbsp; &nbsp; .filterDate(reqStartDate, LSTEndDate.advance(1, 'day'));</pre>
<h5>
<strong><i>Summarize Daily LST by </i></strong><strong>Woreda</strong>
</h5>
<p><span>In the final section for LST, we will perform a zonal mean of the temperature to our <i>woredas</i> and flatten in preparation for export as CSV. </span></p>
<pre>// Part 4.3: Summarize daily LST by woreda<br><br>// Filter LST data for zonal summaries.&nbsp;<br>var LSTSummary = dailyLst<br>&nbsp; &nbsp; .filterDate(reqStartDate, reqEndDate.advance(1, 'day'));<br>// Function to calculate zonal statistics for LST by woreda:<br>function sumZonalLst(image) {<br>&nbsp; &nbsp; // To get the doy and year, we convert the metadata to grids&nbsp;<br>&nbsp; &nbsp; // &nbsp;and then summarize.&nbsp;<br>&nbsp; &nbsp; var image2 = image.addBands([<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('doy').int(),<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('year').int()<br>&nbsp; &nbsp; ]);<br>&nbsp; &nbsp; // Reduce by regions to get zonal means for each county.<br>&nbsp; &nbsp; var output = image2<br>&nbsp; &nbsp; &nbsp; &nbsp; .select(['doy', 'year', 'LST_day', 'LST_night', 'LST_mean'])<br>&nbsp; &nbsp; &nbsp; &nbsp; .reduceRegions({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection: woredas,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reducer: ee.Reducer.mean(),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale: 1000<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; return output;<br>}<br>// Map the zonal statistics function over the filtered LST data.<br>var LSTWoreda = LSTSummary.map(sumZonalLst);<br>// Flatten the results for export.<br>var LSTFlat = LSTWoreda.flatten();</pre>
<p><i style="font-family: 'Lato Extended', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 18px;"></i></p>
<p><i style="font-family: 'Lato Extended', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 18px;">Part 5. Spectral Index: NDWI</i></p>
<p><span>We will follow a similar pattern of steps for our spectral index, NDWI, as we did for precipitation and land surface temperatures: first, calculate the variable(s), then calculate the daily values, and finally summarize by </span><i><span>woreda</span></i><span>.&nbsp;</span></p>
<h5><strong><i>Section 5.1. Calculate NDWI</i></strong></h5>
<p><span>Here we will focus on NDWI, which we actively used to forecast malaria. </span><span>The MODIS MCD43A4 product contains simplified band quality information, and it is recommended to use the additional quality information in the MCD43A2 product for your particular application. We will join these two products to apply our selected quality information. (Note that we do not have to worry about snow in our study area.)</span></p>
<pre>// Part 5: Spectral index NDWI<br><br>// Part 5.1: Calculate NDWI<br><br>// Filter BRDF-Adjusted Reflectance by date.<br>var brdfReflectVars = brdfReflect<br>&nbsp; &nbsp; .filterDate(brdfStartDate, reqEndDate.advance(1, 'day'))<br>&nbsp; &nbsp; .filterBounds(amhara)<br>&nbsp; &nbsp; .select([<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Nadir_Reflectance_Band1', 'Nadir_Reflectance_Band2',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Nadir_Reflectance_Band3', 'Nadir_Reflectance_Band4',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Nadir_Reflectance_Band5', 'Nadir_Reflectance_Band6',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Nadir_Reflectance_Band7'<br>&nbsp; &nbsp; &nbsp; &nbsp; ],<br>&nbsp; &nbsp; &nbsp; &nbsp; ['red', 'nir', 'blue', 'green', 'swir1', 'swir2', 'swir3']);<br><br>// Filter BRDF QA by date.<br>var brdfReflectQa = brdfQa<br>&nbsp; &nbsp; .filterDate(brdfStartDate, reqEndDate.advance(1, 'day'))<br>&nbsp; &nbsp; .filterBounds(amhara)<br>&nbsp; &nbsp; .select([<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band1',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band2',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band3',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band4',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band5',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band6',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_Band_Quality_Band7',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'BRDF_Albedo_LandWaterType'<br>&nbsp; &nbsp; &nbsp; &nbsp; ],<br>&nbsp; &nbsp; &nbsp; &nbsp; ['qa1', 'qa2', 'qa3', 'qa4', 'qa5', 'qa6', 'qa7', 'water']);<br><br>// Join the 2 collections.&nbsp;<br>var idJoin = ee.Filter.equals({<br>&nbsp; &nbsp; leftField: 'system:time_end',<br>&nbsp; &nbsp; rightField: 'system:time_end'<br>});<br>// Define the join.&nbsp;<br>var innerJoin = ee.Join.inner('NBAR', 'QA');<br>// Apply the join.&nbsp;<br>var brdfJoined = innerJoin.apply(brdfReflectVars, brdfReflectQa,<br>&nbsp; &nbsp; idJoin);<br><br>// Add QA bands to the NBAR collection.&nbsp;<br>function addQaBands(image) {<br>&nbsp; &nbsp; var nbar = ee.Image(image.get('NBAR'));<br>&nbsp; &nbsp; var qa = ee.Image(image.get('QA')).select(['qa2']);<br>&nbsp; &nbsp; var water = ee.Image(image.get('QA')).select(['water']);<br>&nbsp; &nbsp; return nbar.addBands([qa, water]);<br>}<br>var brdfMerged = ee.ImageCollection(brdfJoined.map(addQaBands));<br><br>// Function to mask out pixels based on QA and water/land flags.&nbsp;<br>function filterBrdf(image) {<br>&nbsp; &nbsp; // Using QA info for the NIR band.&nbsp;<br>&nbsp; &nbsp; var qaband = image.select(['qa2']);<br>&nbsp; &nbsp; var wband = image.select(['water']);<br>&nbsp; &nbsp; var qamask = qaband.lte(2).and(wband.eq(1));<br>&nbsp; &nbsp; var nir_r = image.select('nir').multiply(0.0001).rename('nir_r');<br>&nbsp; &nbsp; var swir2_r = image.select('swir2').multiply(0.0001).rename(<br>&nbsp; &nbsp; &nbsp; &nbsp; 'swir2_r');<br>&nbsp; &nbsp; return image.addBands(nir_r)<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(swir2_r)<br>&nbsp; &nbsp; &nbsp; &nbsp; .updateMask(qamask);<br>}<br>var brdfFilteredVars = brdfMerged.map(filterBrdf);<br><br>// Function to calculate spectral indices:<br>function calcBrdfIndices(image) {<br>&nbsp; &nbsp; var curyear = ee.Date(image.get('system:time_start')).get('year');<br>&nbsp; &nbsp; var curdoy = ee.Date(image.get('system:time_start'))<br>&nbsp; &nbsp; &nbsp; &nbsp; .getRelative('day', 'year').add(1);<br>&nbsp; &nbsp; var ndwi6 = image.normalizedDifference(['nir_r', 'swir2_r'])<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename('ndwi6');<br>&nbsp; &nbsp; return image.addBands(ndwi6)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('doy', curdoy)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('year', curyear);<br>}<br>// Map function over image collection.&nbsp;<br>brdfFilteredVars = brdfFilteredVars.map(calcBrdfIndices);</pre>
<h5><strong><i>Calculate Daily NDWI</i></strong></h5>
<p><span>Like the other variables, we will calculate a daily value and filter to our user-requested dates, as data exists in that range.</span></p>
<pre>// Part 5.2: Calculate daily NDWI<br><br>// Create list of dates for full time series.<br>var brdfRange = brdfFilteredVars.reduceColumns({<br>&nbsp; &nbsp; reducer: ee.Reducer.max(),<br>&nbsp; &nbsp; selectors: ['system:time_start']<br>});<br>var brdfEndDate = ee.Date(brdfRange.get('max'));<br>var brdfDays = brdfEndDate.difference(brdfStartDate, 'day');<br>var brdfDatesPrep = ee.List.sequence(0, brdfDays, 1);<br><br>function makeBrdfDates(n) {<br>&nbsp; &nbsp; return brdfStartDate.advance(n, 'day');<br>}<br>var brdfDates = brdfDatesPrep.map(makeBrdfDates);<br><br>// List of dates that exist in BRDF data.<br>var brdfDatesExist = brdfFilteredVars<br>&nbsp; &nbsp; .aggregate_array('system:time_start');<br><br>// Get daily brdf values.<br>function calcDailyBrdfExists(curdate) {<br>&nbsp; &nbsp; curdate = ee.Date(curdate);<br>&nbsp; &nbsp; var curyear = curdate.get('year');<br>&nbsp; &nbsp; var curdoy = curdate.getRelative('day', 'year').add(1);<br>&nbsp; &nbsp; var brdfTemp = brdfFilteredVars<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(curdate, curdate.advance(1, 'day'));<br>&nbsp; &nbsp; var outImg = brdfTemp.first();<br>&nbsp; &nbsp; return outImg;<br>}<br>var dailyBrdfExtExists =<br>&nbsp; &nbsp; ee.ImageCollection.fromImages(brdfDatesExist.map(<br>&nbsp; &nbsp; &nbsp; &nbsp; calcDailyBrdfExists));<br><br>// Create empty results, to fill in dates when BRDF data does not exist.<br>function calcDailyBrdfFiller(curdate) {<br>&nbsp; &nbsp; curdate = ee.Date(curdate);<br>&nbsp; &nbsp; var curyear = curdate.get('year');<br>&nbsp; &nbsp; var curdoy = curdate.getRelative('day', 'year').add(1);<br>&nbsp; &nbsp; var brdfTemp = brdfFilteredVars<br>&nbsp; &nbsp; &nbsp; &nbsp; .filterDate(curdate, curdate.advance(1, 'day'));<br>&nbsp; &nbsp; var brdfSize = brdfTemp.size();<br>&nbsp; &nbsp; var outImg = ee.Image.constant(0).selfMask()<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(ee.Image.constant(0).selfMask())<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(ee.Image.constant(0).selfMask())<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(ee.Image.constant(0).selfMask())<br>&nbsp; &nbsp; &nbsp; &nbsp; .addBands(ee.Image.constant(0).selfMask())<br>&nbsp; &nbsp; &nbsp; &nbsp; .rename(['ndvi', 'evi', 'savi', 'ndwi5', 'ndwi6'])<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('doy', curdoy)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('year', curyear)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('system:time_start', curdate)<br>&nbsp; &nbsp; &nbsp; &nbsp; .set('brdfSize', brdfSize);<br>&nbsp; &nbsp; return outImg;<br>}<br>// Create filler for all dates.<br>var dailyBrdfExtendedFiller =<br>&nbsp; &nbsp; ee.ImageCollection.fromImages(brdfDates.map(calcDailyBrdfFiller));<br>// But only used if and when size was 0.<br>var dailyBrdfExtFillFilt = dailyBrdfExtendedFiller<br>&nbsp; &nbsp; .filter(ee.Filter.eq('brdfSize', 0));<br>// Merge the two collections.<br>var dailyBrdfExtended = dailyBrdfExtExists<br>&nbsp; &nbsp; .merge(dailyBrdfExtFillFilt);<br><br>// Filter back to original user requested start date.<br>var dailyBrdf = dailyBrdfExtended<br>&nbsp; &nbsp; .filterDate(reqStartDate, brdfEndDate.advance(1, 'day'));</pre>
<h5>
<strong><i>Summarize Daily Spectral Indices by </i></strong><strong>Woreda</strong>
</h5>
<p><span>Lastly, in our NDWI section, we will use the mean to summarize the values for each <i>woredas</i> and prepare for export by flattening the dataset.</span></p>
<pre>//Part5.3: Summarize daily spectral indices by woreda<br><br>// Filter spectral indices for zonal summaries.<br>var brdfSummary = dailyBrdf<br>&nbsp; &nbsp; .filterDate(reqStartDate, reqEndDate.advance(1, 'day'));<br><br>// Function to calculate zonal statistics for spectral indices by woreda:<br>function sumZonalBrdf(image) {<br>&nbsp; &nbsp; // To get the doy and year, we convert the metadata to grids&nbsp;<br>&nbsp; &nbsp; // &nbsp;and then summarize.<br>&nbsp; &nbsp; var image2 = image.addBands([<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('doy').int(),<br>&nbsp; &nbsp; &nbsp; &nbsp; image.metadata('year').int()<br>&nbsp; &nbsp; ]);<br>&nbsp; &nbsp; // Reduce by regions to get zonal means for each woreda.<br>&nbsp; &nbsp; var output = image2.select(['doy', 'year', 'ndwi6'])<br>&nbsp; &nbsp; &nbsp; &nbsp; .reduceRegions({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection: woredas,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reducer: ee.Reducer.mean(),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale: 1000<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; return output;<br>}<br><br>// Map the zonal statistics function over the filtered spectral index data.<br>var brdfWoreda = brdfSummary.map(sumZonalBrdf);<br>// Flatten the results for export.<br>var brdfFlat = brdfWoreda.flatten();</pre>
<p>&nbsp;</p>
<h4><strong><i>&nbsp;Part 6 - Map Display&nbsp;</i></strong></h4>
<p><span>Here we will look at our calculated variables but before the zonal summary. The full user interface restricts the date to display within the requested range, so be mindful in the code below which date you choose to view.</span></p>
<pre><span>// Part 6: Map display of calculated environmental variables<br><strong>var</strong> displayDate = ee.Date('2021-10-01');<br><br><strong>var</strong> precipDisp = dailyPrecip<br>&nbsp; &nbsp; .filterDate(displayDate, displayDate.advance(1, 'day'));<br><strong>var</strong> brdfDisp = dailyBrdf<br>&nbsp; &nbsp; .filterDate(displayDate, displayDate.advance(1, 'day'));<br><strong>var</strong> LSTDisp = dailyLst<br>&nbsp; &nbsp; .filterDate(displayDate, displayDate.advance(1, 'day'));<br><br>// Select the image (should be only one) from each collection.<br><strong>var</strong> precipImage = precipDisp.first().select('totprec');<br><strong>var</strong> LSTmImage = LSTDisp.first().select('LST_mean');<br><strong>var</strong> ndwi6Image = brdfDisp.first().select('ndwi6');<br><br>// Palettes for environmental variable maps:<br><strong>var</strong> palettePrecip = ['f7fbff', '08306b'];<br><strong>var</strong> paletteLst = ['fff5f0', '67000d'];<br><strong>var</strong> paletteSpectral = ['ffffe5', '004529'];<br><br>// Add layers to the map.<br>// Show precipitation by default, <br>//&nbsp; others hidden until users picks them from layers drop down. <br>Map.addLayer({<br>&nbsp; &nbsp; eeObject: precipImage,<br>&nbsp; &nbsp; visParams: {<br>&nbsp; &nbsp; &nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; &nbsp; &nbsp; max: 20,<br>&nbsp; &nbsp; &nbsp; &nbsp; palette: palettePrecip<br>&nbsp; &nbsp; },<br>&nbsp; &nbsp; name: 'Precipitation',<br>&nbsp; &nbsp; shown: <strong>true</strong>,<br>&nbsp; &nbsp; opacity: 0.75<br>});<br>Map.addLayer({<br>&nbsp; &nbsp; eeObject: LSTmImage,<br>&nbsp; &nbsp; visParams: {<br>&nbsp; &nbsp; &nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; &nbsp; &nbsp; max: 40,<br>&nbsp; &nbsp; &nbsp; &nbsp; palette: paletteLst<br>&nbsp; &nbsp; },<br>&nbsp; &nbsp; name: 'LST Mean',<br>&nbsp; &nbsp; shown: <strong>false</strong>,<br>&nbsp; &nbsp; opacity: 0.75<br>});<br>Map.addLayer({<br>&nbsp; &nbsp; eeObject: ndwi6Image,<br>&nbsp; &nbsp; visParams: {<br>&nbsp; &nbsp; &nbsp; &nbsp; min: 0,<br>&nbsp; &nbsp; &nbsp; &nbsp; max: 1,<br>&nbsp; &nbsp; &nbsp; &nbsp; palette: paletteSpectral<br>&nbsp; &nbsp; },<br>&nbsp; &nbsp; name: 'NDWI6',<br>&nbsp; &nbsp; shown: <strong>false</strong>,<br>&nbsp; &nbsp; opacity: 0.75<br>});</span></pre>
<p><span><img src="../images/canvas/Uploaded%20Media/Screenshot%202023-04-14%20at%201.53.23%20AM.png" alt="results after part 6"   loading="lazy"></span></p>
<h4><strong><i></i></strong></h4>
<h4><strong><i>Part 7 - Exporting&nbsp;</i></strong></h4>
<p><span>Two important strengths of Google Earth Engine are the ability to gather and process the remotely sensed data in the cloud and to have the only download be a small text file ready to use in the forecasting software. Most of our project partners were public health experts and did not have a remote sensing or programming background. We also had partners in areas of limited or unreliable internet connectivity. We needed something that could be easily usable by our users in these types of situations.&nbsp;</span></p>
<p><span>This section will create small text CSV downloads for each of our three environmental factors prepared earlier. Each factor may have different data availability within the user’s requested range. These dates will be added to the file name to indicate the actual date range of the downloaded data.&nbsp;</span></p>
<pre><span>// Part 7: Exporting</span><span><br></span><span><br></span><span>// 7.1 Export naming</span><span><br></span><strong>var</strong><span> reqStartDateText = reqStartDate.</span><span>format</span><span>(</span><span>'yyyy-MM-dd'</span><span>).</span><span>getInfo</span><span>();</span><span><br></span><span><br></span><span>// Precipitation</span><span><br></span><strong>var</strong><span> precipPrefix = </span><span>'Export_Precip_Data'</span><span>;</span><span><br></span><strong>var</strong><span> precipLastDate = </span><span>ee</span><span>.</span><span>Date</span><span>(reqEndDate.</span><span>millis</span><span>()</span><span><br></span><span>&nbsp; &nbsp; .</span><span>min</span><span>(precipEndDate.</span><span>millis</span><span>()));</span><span><br></span><strong>var</strong><span> precipSummaryEndDate = precipLastDate</span><span><br></span><span>&nbsp; &nbsp; .</span><span>format</span><span>(</span><span>'yyyy-MM-dd'</span><span>).</span><span>getInfo</span><span>();</span><span><br></span><strong>var</strong><span> precipFilename = precipPrefix</span><span><br></span><span>&nbsp; &nbsp; .</span><span>concat</span><span>(</span><span>'_'</span><span>, reqStartDateText,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'_'</span><span>, precipSummaryEndDate);</span><span><br></span><span>// LST</span><span><br></span><strong>var</strong><span> LSTPrefix = </span><span>'Export_LST_Data'</span><span>;</span><span><br></span><strong>var</strong><span> LSTLastDate = </span><span>ee</span><span>.</span><span>Date</span><span>(reqEndDate.</span><span>millis</span><span>()</span><span><br></span><span>&nbsp; &nbsp; .</span><span>min</span><span>(LSTEndDate.</span><span>millis</span><span>()));</span><span><br></span><strong>var</strong><span> LSTSummaryEndDate = LSTLastDate</span><span><br></span><span>&nbsp; &nbsp; .</span><span>format</span><span>(</span><span>'yyyy-MM-dd'</span><span>).</span><span>getInfo</span><span>();</span><span><br></span><strong>var</strong><span> LSTFilename = LSTPrefix</span><span><br></span><span>&nbsp; &nbsp; .</span><span>concat</span><span>(</span><span>'_'</span><span>, reqStartDateText,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'_'</span><span>, LSTSummaryEndDate);</span><span><br></span><span>// BRDF</span><span><br></span><strong>var</strong><span> brdfPrefix = </span><span>'Export_Spectral_Data'</span><span>;</span><span><br></span><strong>var</strong><span> brdfLastDate = </span><span>ee</span><span>.</span><span>Date</span><span>(reqEndDate.</span><span>millis</span><span>()</span><span><br></span><span>&nbsp; &nbsp; .</span><span>min</span><span>(brdfEndDate.</span><span>millis</span><span>()));</span><span><br></span><strong>var</strong><span> brdfSummaryEndDate = brdfLastDate</span><span><br></span><span>&nbsp; &nbsp; .</span><span>format</span><span>(</span><span>'yyyy-MM-dd'</span><span>).</span><span>getInfo</span><span>();</span><span><br></span><strong>var</strong><span> brdfFilename = brdfPrefix</span><span><br></span><span>&nbsp; &nbsp; .</span><span>concat</span><span>(</span><span>'_'</span><span>, reqStartDateText,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'_'</span><span>, brdfSummaryEndDate);</span><span><br></span><span><br></span><span>// 7.2 Export flattened tables to Google Drive</span><span><br></span><span>// Need to click 'RUN in the Tasks tab to configure and start each export.</span><span><br></span><span>Export</span><span>.</span><span>table.toDrive</span><span>({</span><span><br></span><span>&nbsp; &nbsp; collection: precipFlat,</span><span><br></span><span>&nbsp; &nbsp; description: precipFilename,</span><span><br></span><span>&nbsp; &nbsp; selectors: [</span><span>'wid'</span><span>, </span><span>'woreda'</span><span>, </span><span>'doy'</span><span>, </span><span>'year'</span><span>, </span><span>'totprec'</span><span>]</span><span><br></span><span>});</span><span><br></span><span>Export</span><span>.</span><span>table.toDrive</span><span>({</span><span><br></span><span>&nbsp; &nbsp; collection: LSTFlat,</span><span><br></span><span>&nbsp; &nbsp; description: LSTFilename,</span><span><br></span><span>&nbsp; &nbsp; selectors: [</span><span>'wid'</span><span>, </span><span>'woreda'</span><span>, </span><span>'doy'</span><span>, </span><span>'year'</span><span>,</span><span><br></span><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>'LST_day'</span><span>, </span><span>'LST_night'</span><span>, </span><span>'LST_mean'</span><span><br></span><span>&nbsp; &nbsp; ]</span><span><br></span><span>});</span><span><br></span><span>Export</span><span>.</span><span>table.toDrive</span><span>({</span><span><br></span><span>&nbsp; &nbsp; collection: brdfFlat,</span><span><br></span><span>&nbsp; &nbsp; description: brdfFilename,</span><span><br></span><span>&nbsp; &nbsp; selectors: [</span><span>'wid'</span><span>, </span><span>'woreda'</span><span>, </span><span>'doy'</span><span>, </span><span>'year'</span><span>, </span><span>'ndwi6'</span><span>]</span><span><br></span><span>});</span></pre>
<p><span>Hit Run and then pay attention to your Task Tab.&nbsp; &nbsp;</span><span>In the Earth Engine </span><strong>Tasks</strong><span> tab, click </span><strong>Run</strong><span> to configure and start each export to Google Drive.&nbsp;</span></p>
<p><span><img src="../images/canvas/Uploaded%20Media/Screenshot%202023-04-14%20at%201.57.03%20AM.png" alt="Screenshot 2023-04-14 at 1.57.03 AM.png"   loading="lazy"></span></p>
<p><span><img src="../images/canvas/Uploaded%20Media/Screenshot%202023-04-14%20at%201.59.54%20AM.png" alt="example of export settings" width="478" height="453"   loading="lazy"></span></p>
<p><span>After exporting the files, you will find CSV files in your Google Drive.&nbsp; These can be easily opened in Excel or other software packages like R to do modeling.&nbsp;</span></p>
<p><span><img src="../images/canvas/Uploaded%20Media/Screenshot%202023-04-14%20at%201.58.31%20AM.png" alt="excel sheet of csv file"   loading="lazy"></span></p>
<h2><strong>Submit the CSV files you exported on Canvas</strong></h2>
<p><strong>References</strong></p>
<p><span>Ford TE, Colwell RR, Rose JB, et al (2009) Using satellite images of environmental changes to predict infectious disease outbreaks. Emerg Infect Dis 15:1341–1346. https://doi.org/10.3201/eid/1509.081334</span></p>
<p><span>Franklinos LHV, Jones KE, Redding DW, Abubakar I (2019) The effect of global change on mosquito-borne disease. Lancet Infect Dis 19:e302–e312. https://doi.org/10.1016/S1473-3099(19)30161-6</span></p>
<p><span>Jones KE, Patel NG, Levy MA, et al (2008) Global trends in emerging infectious diseases. Nature 451:990–993. https://doi.org/10.1038/nature06536</span></p>
<p><span>Mackenzie JS, Jeggo M (2019) The one health approach</span><span>–</span><span>why is it so important? Trop. Med. Infect. Dis. 4:88. https://doi.org/10.3390/tropicalmed4020088</span></p>
<p><span>Wimberly MC, de Beurs KM, Loboda T V., Pan WK (2021) Satellite observations and malaria: New opportunities for research and applications. Trends Parasitol 37:525–537. https://doi.org/10.1016/j.pt.2021.03.003</span></p>
<p><span>Wimberly MC, Nekorchuk DM, Kankanala RR (2022) Cloud-based applications for accessing satellite Earth observations to support malaria early warning. Sci Data 9:1–11. https://doi.org/10.1038/s41597-022-01337-y</span></p>
<p><span>World Health Organization (2018) Malaria surveillance, monitoring and evaluation: a reference manual. World Health Organization</span></p>
<p><span>World Health Organization (2020) World Malaria Report 2020: 20 years of global progress and challenges. World Health Organization</span></p>
            <section id="submission">
                <div class="submission-box">
                    <h3>Lab Submission</h3>
                    <p>Submit lab via email.</p>
                    <p><strong>Subject:</strong> <code>Lab 17 - Health Applications Part 1 - [Your Name]</code></p>
                </div>
            </section>
        </main>

        <footer>
            <p><a href='lab-16-zonal-statistics.html'>&larr; Previous Lab</a> | <a href='lab-18-health-applications-part2.html'>Next Lab &rarr;</a></p>
            <p><a href="../index.html">&larr;Back to Course Home</a></p>
        </footer>
    </div>
    
</body>
</html>

